<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>
<rfc ipr="trust200902"   category="std"
    docName="draft-ietf-netconf-restconf.xml" >
    <front>
    <title abbrev="RESTCONF">RESTCONF Protocol</title>

    <author initials="A" surname="Bierman" fullname='Andy Bierman' >
      <organization>YumaWorks</organization>
      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>
    <author initials="M" surname="Bjorklund" fullname='Martin Bjorklund' >
      <organization>Tail-f Systems</organization>
      <address>
        <email>mbj@tail-f.com</email>
      </address>
    </author>
    <author initials="K" surname="Watsen" fullname='Kent Watsen' >
      <organization>Juniper Networks</organization>
      <address>
        <email>kwatsen@juniper.net</email>
      </address>
    </author>
    <author initials="R" surname="Fernando" fullname='Rex Fernando' >
      <organization>Cisco</organization>
      <address>
        <email>rex@cisco.com</email>
      </address>
    </author>
	<date/>
    <abstract>
	<t>
This document describes an HTTP-based protocol that provides
a programmatic interface for accessing data defined in YANG,
using the datastores defined in NETCONF.
	</t>
</abstract>
</front>
<middle>
<section title="Introduction">
    <t>
There is a need for standard mechanisms to allow WEB applications
to access the configuration data, operational data,
data-model specific protocol operations, and notification events
within a networking device, in a modular and extensible manner.
    </t>
    <t>
This document describes an HTTP <xref target="RFC2616"/> based protocol called
RESTCONF, for accessing data defined in YANG <xref target="RFC6020"/>, using
datastores defined in NETCONF <xref target="RFC6241"/>.
    </t>
    <t>
The NETCONF protocol defines configuration datastores and
a set of Create, Retrieve, Update, Delete (CRUD) operations
that can be used to access these datastores.  The YANG language
defines the syntax and semantics of datastore content,
operational data, protocol operations, and notification events.
RESTCONF uses HTTP operations to provide CRUD operations on a
NETCONF datastore containing YANG-defined data.  Since NETCONF
protocol operations are not relevant, the user should
not need any prior knowledge of NETCONF in order to use RESTCONF.
    </t>
    <t>
Configuration data and state data are exposed as resources that
can be retrieved with the GET method.
Resources representing configuration data
can be modified with the DELETE, PATCH, POST, and PUT methods.
Data is encoded with either XML <xref target="W3C.REC-xml-20081126"/>
or JSON <xref target="JSON"/>.
    </t>
    <t>
Data-model specific protocol operations defined with
the YANG &quot;rpc&quot; statement can be invoked with the POST method.
Data-model specific notification events defined with
the YANG &quot;notification&quot; statement can be accessed.
    </t>
<section title="Secure Transport">
    <t>
RESTCONF relies on TLS <xref target="RFC2246"/> to provide privacy and data
integrity for its HTTP operations.  More specifically,
RESTCONF requires HTTP over TLS (HTTPS) <xref target="RFC2818"/>.  To ensure
security, RESTCONF clients MUST verify the RESTCONF server&apos;s
X.509 certificate using the path validation algorithm defined in
section 6 of <xref target="RFC5280"/>.  Devices that do not support TLS will
be unable to implement RESTCONF.
    </t>
</section>
<section title="Simple Subset of NETCONF Functionality">
    <t>
The framework and meta-model used for an HTTP-based API does not need to
mirror those used by the NETCONF protocol, but it needs to
be compatible with NETCONF.  A simplified framework and protocol
is needed that utilizes the three NETCONF datastores (candidate,
running, startup), but hides the complexity of multiple datastores
from the client.
    </t>
    <t>
A simplified transaction model is needed that allows basic
CRUD operations on a hierarchy of conceptual resources.
This represents a limited subset of the transaction capabilities
of the NETCONF protocol.
    </t>
    <t>
Applications that require more complex transaction capabilities
might consider NETCONF instead of RESTCONF.  The following
transaction features are not directly provided in RESTCONF:
    </t>
<t>
 <list style="symbols">
 <t>
datastore locking (full or partial)
 </t>
 <t>
candidate datastore
 </t>
 <t>
startup datastore
 </t>
 <t>
validate operation
 </t>
 <t>
confirmed-commit procedure
 </t>
 </list>
</t>
    <t>
RESTCONF is not intended to replace NETCONF, but rather provide
an additional simplified interface that follows REST principles and
is compatible with a resource-oriented device abstraction.
    </t>
    <t>
The following figure shows the system components:
    </t>
	<figure>
	    <artwork><![CDATA[
      +-----------+           +-----------------+
      |  WEB app  | <-------> |                 |
      +-----------+   HTTP    | network device  |
                              |                 |
      +-----------+           |   +-----------+ |
      |  NMS app  | <-------> |   | datastore | |
      +-----------+  NETCONF  |   +-----------+ |
                              +-----------------+
	    ]]></artwork>
	</figure>
</section>
<section title="Data Model Driven API">
    <t>
RESTCONF combines the simplicity of the HTTP protocol with the
predictability and automation potential of a schema-driven API.
Using YANG, a client can predict all resource endpoints, much
like using URI Templates <xref target="RFC6570"/>, but in a more holistic
manner.   This strategy obviates the need for responses provided
by the server to contain HATEOAS links, originally described in
Roy Fielding&apos;s doctoral dissertation <xref target="rest-dissertation"/>.
    </t>
    <t>
A REST client using HATEOAS principles would not use
any data modeling language to define the application-specific content
of the API.  The client would discover each new child
resource as it traverses the URIs returned as Location IDs
to discover the server capabilities.  This approach has 3 significant
weaknesses with regards to control of complex networking devices:
    </t>
<t>
 <list style="symbols">
 <t>
inefficient performance: configuration APIs will be quite
complex and may require thousands of protocol messages to
discover all the schema information.  Typically the
data type information has to be passed in the protocol messages,
which is also wasteful overhead.
 </t>
 <t>
no data model richness: without a data model, the schema-level
semantics and validation constraints are not available to the
application.
 </t>
 <t>
no tool automation: API automation tools need some sort of
content schema to function.  Such tools can automate
various programming and documentation tasks related
to specific data models.
 </t>
 </list>
</t>
    <t>
Data model modules such as YANG modules serve as an &quot;API contract&quot;
that will be honored by the server.  An application designer
can code to the data model, knowing in advance important details
about the exact protocol operations and datastore content
a conforming server implementation will support.
    </t>
    <t>
RESTCONF provides the YANG module capability information
supported by the server, in case the client wants to use it.
The URIs for custom protocol operations and datastore content
are predictable, based on the YANG module definitions.
    </t>
    <t>
Operational experience with CLI and SNMP indicates that
operators learn the &apos;location&apos; of specific service
or device related data and do not expect such information
to be arbitrary and discovered each time the
client opens a management session to a server.
    </t>
    <t>
The RESTCONF protocol operates on a conceptual datastore defined with
the YANG data modeling language.  The server lists each YANG
module it supports under &quot;{+restconf}/modules&quot;
in the top-level API resource type, using a structure based on
the YANG module capability URI format defined in <xref target="RFC6020"/>.
    </t>
    <t>
The conceptual datastore contents, data-model-specific
operations and notification events are identified by this set of
YANG module resources.  All RESTCONF content identified
as either a data resource, operation resource, or event stream resource
is defined with the YANG language.
    </t>
    <t>
The classification of data as configuration or
non-configuration is derived from the YANG &quot;config&quot; statement.
Data ordering behavior is derived from the YANG &quot;ordered&#8209;by&quot;
statement.
    </t>
    <t>
The RESTCONF datastore editing model is simple and direct,
similar to the behavior of the &quot;:writable&#8209;running&quot;
capability in NETCONF. Each RESTCONF edit of a datastore
resource is activated upon successful completion of the transaction.
    </t>
</section>
<section title="Terminology">
    <t>
The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
14, <xref target="RFC2119"/>.
    </t>
<section title="NETCONF">
    <t>
The following terms are defined in <xref target="RFC6241"/>:
    </t>
<t>
 <list style="symbols">
 <t>
candidate configuration datastore
 </t>
 <t>
client
 </t>
 <t>
configuration data
 </t>
 <t>
datastore
 </t>
 <t>
configuration datastore
 </t>
 <t>
protocol operation
 </t>
 <t>
running configuration datastore
 </t>
 <t>
server
 </t>
 <t>
startup configuration datastore
 </t>
 <t>
state data
 </t>
 <t>
user
 </t>
 </list>
</t>
</section>
<section title="HTTP">
    <t>
The following terms are defined in <xref target="RFC2616"/>:
    </t>
<t>
 <list style="symbols">
 <t>
entity tag
 </t>
 <t>
fragment
 </t>
 <t>
header line
 </t>
 <t>
message body
 </t>
 <t>
method
 </t>
 <t>
path
 </t>
 <t>
query
 </t>
 <t>
request
 </t>
 <t>
request URI
 </t>
 <t>
response body
 </t>
 <t>
resource
 </t>
 </list>
</t>
</section>
<section title="YANG">
    <t>
The following terms are defined in <xref target="RFC6020"/>:
    </t>
<t>
 <list style="symbols">
 <t>
container
 </t>
 <t>
data node
 </t>
 <t>
key leaf
 </t>
 <t>
leaf
 </t>
 <t>
leaf-list
 </t>
 <t>
list
 </t>
 <t>
presence container (or P-container)
 </t>
 <t>
RPC operation (now called protocol operation)
 </t>
 <t>
non-presence container (or NP-container)
 </t>
 <t>
ordered-by system
 </t>
 <t>
ordered-by user
 </t>
 </list>
</t>
</section>
<section title="Terms">
    <t>
The following terms are used within this document:
    </t>
<t>
 <list style="symbols">
 <t>
API resource: a resource with the media type
&quot;application/yang.api+xml&quot; or &quot;application/yang.api+json&quot;.
API resources can only be edited by the server.
 </t>
 <t>
data resource: a resource with the media type
&quot;application/yang.data+xml&quot; or &quot;application/yang.data+json&quot;.
Data resources can be edited by clients or the server.
All YANG data node types can be data resources.
YANG terminal nodes cannot contain child resources.
 </t>
 <t>
datastore resource: a resource with the media type
&quot;application/yang.datastore+xml&quot; or
&quot;application/yang.datastore+json&quot;. Represents a configuration
datastore.
 </t>
 <t>
edit operation: a RESTCONF operation on a data resource
using the POST, PUT, PATCH, or DELETE method.
 </t>
 <t>
event stream resource: a resource with the media type
&quot;application/yang.stream+xml&quot; or
&quot;application/yang.stream+json&quot;. This resource represents
an SSE (Server-Sent Events) event stream. The content consists of text
using the media type &quot;text/event&#8209;stream&quot;, as defined by the HTML5
specification. Each event represents
one &lt;notification&gt; message generated by the server.
It contains a conceptual system or data-model specific event
that is delivered within a notification event stream.
 </t>
 <t>
operation: the conceptual RESTCONF operation for a message,
derived from the HTTP method, request URI, headers, and message body.
 </t>
 <t>
operation resource: a resource with the media type
&quot;application/yang.operation+xml&quot; or
&quot;application/yang.operation+json&quot;.
 </t>
 <t>
patch: a generic PATCH request on the target datastore
or data resource.
The media type of the message body content will identify
the patch type in use.
 </t>
 <t>
plain patch: a PATCH request where the media type
is &quot;application/yang.data+xml&quot; or &quot;application/yang.data+json&quot;.
 </t>
 <t>
query parameter: a parameter (and its value if any),
encoded within the query component of the request URI.
 </t>
 <t>
retrieval request: a request using the GET or HEAD methods.
 </t>
 <t>
target resource: the resource that is associated with
a particular message, identified by the &quot;path&quot; component
of the request URI.
 </t>
 <t>
unified datastore: A conceptual representation of the device
running configuration. The server will hide all NETCONF datastore
details for edit operations, such as the &quot;:candidate&quot; and &quot;:startup&quot;
capabilities.
 </t>
 <t>
schema resource: a resource with the media type
&quot;application/yang&quot;. The YANG representation of the schema
can be retrieved by the client with the GET method.
 </t>
 <t>
YANG terminal node: a YANG node representing a leaf,
leaf-list, or anyxml definition.
 </t>
 </list>
</t>
</section>
<section title="Tree Diagrams">
    <t>
A simplified graphical representation of the data model is used in
this document.  The meaning of the symbols in these
diagrams is as follows:
    </t>
<t>
 <list style="symbols">
 <t>
Brackets &quot;[&quot; and &quot;]&quot; enclose list keys.
 </t>
 <t>
Abbreviations before data node names: &quot;rw&quot; means configuration
data (read-write) and &quot;ro&quot; state data (read-only).
 </t>
 <t>
Symbols after data node names: &quot;?&quot; means an optional node, &quot;!&quot; means
a presence container, and &quot;*&quot; denotes a list and leaf-list.
 </t>
 <t>
Parentheses enclose choice and case nodes, and case nodes are also
marked with a colon (&quot;:&quot;).
 </t>
 <t>
Ellipsis (&quot;...&quot;) stands for contents of subtrees that are not shown.
 </t>
 </list>
</t>
</section>
</section>
</section>
<section title="Resources" anchor="resources">
    <t>
The RESTCONF protocol operates on a hierarchy of resources,
starting with the top-level API resource itself. Each resource
represents a manageable component within the device.
    </t>
    <t>
A resource can be considered a collection of conceptual data and the
set of allowed methods on that data.  It can contain nested child
resources.  The child resource types and methods allowed on them are
data-model specific.
    </t>
    <t>
A resource has its own media type identifier, represented
by the &quot;Content&#8209;Type&quot; header in the HTTP response message.
A resource can contain zero or more nested resources.
A resource can be created and deleted independently of its
parent resource, as long as the parent resource exists.
    </t>
    <t>
All RESTCONF resources are defined in this document except
datastore contents, protocol operations, and notification events.
The syntax and semantics for these resource types are
defined in YANG modules.
    </t>
    <t>
The RESTCONF resources are accessed via a set of
URIs defined in this document.
The set of YANG modules supported by the server
will determine the data model specific operations,
top-level data node resources, and notification event messages
supported by the server.
    </t>
    <t>
The resources used in the RESTCONF protocol are identified
by the &quot;path&quot; component in the request URI.  Each operation
is performed on a target resource.
    </t>
<section title="RESTCONF Resource Types">
    <t>
The RESTCONF protocol defines a set of application specific media
types to identify each of the available resource types.  The following
resource types are defined in RESTCONF:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Media Types">
<ttcol align='left'> Resource</ttcol>
<ttcol align='left'>Media Type</ttcol>
<c>API</c>
<c>application/yang.api</c>
<c>Datastore</c>
<c>application/yang.datastore</c>
<c>Data</c>
<c>application/yang.data</c>
<c>Errors</c>
<c>application/yang.errors</c>
<c>Operation</c>
<c>application/yang.operation</c>
<c>Schema</c>
<c>application/yang</c>
<c>Stream</c>
<c>application/yang.stream</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Resource Discovery" anchor="resource-discovery">
    <t>
A client SHOULD start by retrieving the top-level API resource,
using the entry point URI defined in <xref target="path-resolution"/>.
    </t>
    <t>
The RESTCONF protocol does not include a
resource discovery mechanism.  Instead, the definitions
within the YANG modules advertised by the server
are used to construct a predictable operation or data
resource identifier.
    </t>
    <t>
The &quot;depth&quot; query parameter can be used to control how many
descendant levels should be included when retrieving
child resources. This parameter can be used with the GET method
to discover child resources within a particular resource.
    </t>
</section>
<section title="API Resource" anchor="api-resource">
    <t>
The API resource contains the state and access points for
the RESTCONF features.
It is the top-level resource and has the media type
&quot;application/yang.api+xml&quot; or &quot;application/yang.api+json&quot;.
    </t>
    <t>
YANG Tree Diagram for &quot;application/yang.api&quot; Resource Type:
    </t>
	<figure>
	    <artwork><![CDATA[
   +--rw restconf
      +--rw data
      +--rw modules
      |  +--rw module* [name revision]
      |     +--rw name         yang:yang-identifier
      |     +--rw revision     union
      |     +--rw schema?      empty
      |     +--rw namespace    inet:uri
      |     +--rw feature*     yang:yang-identifier
      |     +--rw deviation*   yang:yang-identifier
      |     +--rw submodule* [name revision]
      |        +--rw name        yang:yang-identifier
      |        +--rw revision    union
      |        +--rw schema?     empty
      +--rw operations
      +--rw streams
         +--rw stream* [name]
            +--rw name                        string
            +--rw description?                string
            +--rw replay-support?             boolean
            +--rw replay-log-creation-time?   yang:date-and-time
            +--rw events?                     empty
	    ]]></artwork>
	</figure>
    <t>
The &quot;restconf&quot; container definition in the &quot;ietf&#8209;restconf&quot; module
defined in <xref target="module"/> is used to specify the structure and syntax
of the conceptual child resources within the API resource.
    </t>
    <t>
This resource has the following child resources:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Resources">
<ttcol align='left'> Child Resource</ttcol>
<ttcol align='left'>Description</ttcol>
<c>data</c>
<c>Contains all data resources</c>
<c>modules</c>
<c>YANG module information</c>
<c>operations</c>
<c>Data-model specific operations</c>
<c>streams</c>
<c>Notification event streams</c>
</texttable>
<?rfc compact="no"?><section title="{+restconf}/data">
    <t>
This mandatory resource represents the combined configuration
and operational data resources that can be accessed by a client.
It cannot be created or deleted by the client.
The datastore resource type is defined in <xref target="datastore-resource"/>.
    </t>
    <t>
Example:
    </t>
    <t>
This example request by the client
would retrieve only the non-configuration data nodes
that exist within the &quot;library&quot; resource, using the &quot;content&quot;
query parameter.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox/library
      ?content=nonconfig  HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-jukebox:library" : {
        "artist-count" : 42,
        "album-count" : 59,
        "song-count" : 374
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="{+restconf}/modules">
    <t>
This mandatory resource contains the identifiers
for the YANG data model modules supported by the server.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this
resource, and return the &quot;Last&#8209;Modified&quot; header when this
resource is retrieved with the GET or HEAD methods.
    </t>
    <t>
The server SHOULD maintain an entity-tag for this
resource, and return the &quot;ETag&quot; header when this
resource is retrieved with the GET or HEAD methods.
    </t>
<section title="{+restconf}/modules/module">
    <t>
This mandatory resource contains one list entry
for each YANG data model module supported by the server.
There MUST be an instance of this resource for every
YANG module that is accessible via an operation resource
or a data resource.
    </t>
    <t>
The contents of the &quot;module&quot; resource are defined in
the &quot;module&quot; YANG list statement in <xref target="module"/>.
    </t>
    <t>
The server MAY maintain a last-modified timestamp for
each instance of this resource, and return the
&quot;Last&#8209;Modified&quot; header when this resource is retrieved
with the GET or HEAD methods.  If not supported
then the timestamp for the parent &quot;modules&quot; resource
MAY be used instead.
    </t>
    <t>
The server MAY maintain an entity-tag for each instance
of this resource, and return the &quot;ETag&quot; header when this
resource is retrieved with the GET or HEAD methods.
If not supported then the timestamp for the
parent &quot;modules&quot; resource MAY be used instead.
    </t>
</section>
</section>
<section title="{+restconf}/operations">
    <t>
This optional resource is a container that provides access to the
data-model specific protocol operations supported by the server.
The server MAY omit this resource if no data-model specific
operations are advertised.
    </t>
    <t>
Any data-model specific operations defined in the YANG
modules advertised by the server MAY be available
as child nodes of this resource.
    </t>
    <t>
Operation resources are defined in <xref target="operation-resource"/>.
    </t>
</section>
<section title="{+restconf}/streams">
    <t>
This optional resource is a container that provides access to the
notification event streams supported by the server.
The server MAY omit this resource if no
notification event streams are supported.
The media type for this resource is &quot;application/yang.api&quot;.
    </t>
    <t>
The server will populate this container with a stream list entry for
each stream type it supports.  Each stream contains a leaf
called &quot;events&quot; which represents an event stream resource.
The media type for this resource is &quot;application/yang.stream&quot;.
    </t>
    <t>
Stream resources are defined in <xref target="stream-resource"/>.
Notifications are defined in <xref target="notifications"/>.
    </t>
</section>
</section>
<section title="Datastore Resource" anchor="datastore-resource">
    <t>
The &quot;{+restconf}/data&quot; subtree represents the datastore resource type,
which is a collection of configuration and operational data nodes.
    </t>
    <t>
A &quot;unified datastore&quot; interface is used to simplify resource
editing for the client. The RESTCONF unified datastore is a
conceptual interface to the native configuration datastores
that are present on the device.
    </t>
    <t>
The underlying NETCONF datastores (i.e., candidate, running, startup)
can be used to implement the unified datastore, but the server design
is not limited to the exact datastore procedures defined
in NETCONF.
    </t>
    <t>
The &quot;candidate&quot; and &quot;startup&quot; datastores are not visible
in the RESTCONF protocol.  Transaction management and
configuration persistence are handled by the server
and not controlled by the client.
    </t>
    <t>
A datastore resource can only be written directly with
the PATCH method. Only the configuration data resources
within the datastore resource can be edited directly with
all methods.
    </t>
    <t>
Each RESTCONF edit of a datastore resource is
saved to non-volatile storage in an
implementation-specific matter by the server.
There is no guarantee that configuration changes
are saved immediately, or that the saved configuration
is always a mirror of the running configuration.
    </t>
<section title="Edit Collision Detection" anchor="edit-collision">
    <t>
Two &quot;edit collision detection&quot; mechanisms are provided
in RESTCONF, for datastore and data resources.
    </t>
<section title="Timestamp">
    <t>
The last change time is maintained and
the &quot;Last&#8209;Modified&quot; and &quot;Date&quot; headers are returned in the
response for a retrieval request.
The &quot;If&#8209;Unmodified&#8209;Since&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource has been modified
since the specified timestamp.
    </t>
    <t>
The server MUST maintain a last-modified timestamp for this
resource, and return the &quot;Last&#8209;Modified&quot; header when this
resource is retrieved with the GET or HEAD methods.
Only changes to configuration data resources within
the datastore affect this timestamp.
    </t>
</section>
<section title="Entity tag">
    <t>
A unique opaque string is maintained and
the &quot;ETag&quot; header is returned in the
response for a retrieval request.
The &quot;If&#8209;Match&quot; header can be used
in edit operation requests to cause the server
to reject the request if the resource entity tag
does not match the specified value.
    </t>
    <t>
The server MUST maintain a resource entity tag for this
resource, and return the &quot;ETag&quot; header when this
resource is retrieved with the GET or HEAD methods.
The resource entity tag MUST be changed to a new
previously unused value if changes to any configuration
data resources within the datastore are made.
    </t>
</section>
</section>
</section>
<section title="Data Resource" anchor="data-resource">
    <t>
A data resource represents a YANG data node that is a descendant
node of a datastore resource.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a last-modified timestamp for the
resource, and return the &quot;Last&#8209;Modified&quot; header when it
is retrieved with the GET or HEAD methods.
If maintained, the resource timestamp MUST be set to the current
time whenever the resource
or any configuration resource within the resource is altered.
    </t>
    <t>
For configuration data resources,
the server MAY maintain a resource entity tag for the
resource, and return the &quot;ETag&quot; header when it
is retrieved as the target resource with the GET or HEAD methods.
If maintained, the resource entity tag MUST be updated
whenever the resource
or any configuration resource within the resource is altered.
    </t>
    <t>
A data resource can be retrieved with the GET method.
Data resources are accessed via the &quot;{+restconf}/data&quot; entry point.
This sub-tree is used to retrieve and edit data resources.
    </t>
    <t>
A configuration data resource can be altered by the client
with some or all of the edit operations, depending on the
target resource and the specific operation. Refer to <xref target="operations"/>
for more details on edit operations.
    </t>
    <t>
The resource definition version for a data resource
is identified by the revision date of the YANG module
containing the YANG definition for the data resource,
specified in the &quot;{+restconf}/modules&quot; sub-tree.
    </t>
<section title="Encoding YANG Instance Identifiers in the Request URI" anchor="uri-encoding">
    <t>
In YANG, data nodes are named with an absolute
XPath expression, defined in <xref target="XPath"/> , starting
from the document root to the target resource.
In RESTCONF, URL encoded Location header expressions are used instead.
    </t>
    <t>
The YANG &quot;instance&#8209;identifier&quot; (i-i) data type is represented
in RESTCONF with the path expression format defined
in this section.
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF instance-identifier Type Conversion">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Comments</ttcol>
<c>point</c>
<c>Insertion point is always a full i-i</c>
<c>path</c>
<c>Request URI path is a full or partial i-i</c>
</texttable>
<?rfc compact="no"?>    <t>
The &quot;path&quot; component of the request URI contains the
absolute path expression that identifies the
target resource.
    </t>
    <t>
A predictable location for a data resource
is important, since applications will code to the YANG
data model module, which uses static naming and defines an
absolute path location for all data nodes.
    </t>
    <t>
A RESTCONF data resource identifier is not an XPath expression.
It is encoded from left to right, starting with the top-level
data node, according to the &quot;api&#8209;path&quot; rule in <xref target="path-abnf"/>.
The node name of each ancestor of the target resource node
is encoded in order, ending with the node name for the
target resource.
    </t>
    <t>
If a data node in the path expression is a YANG list node,
then the key values for the list (if any) MUST be encoded
according to the following rules.
    </t>
<t>
 <list style="symbols">
 <t>
The key leaf values for a data resource representing a YANG
list MUST be encoded using one path segment <xref target="RFC3986"/>.
 </t>
 <t>
If there is only one key leaf value, the path segment is constructed
by having the list name followed by an &quot;=&quot; followed by the single key
leaf value.
 </t>
 <t>
If there are multiple key leaf values, the value of each leaf
identified in the &quot;key&quot; statement is encoded 
in the order specified in the YANG &quot;key&quot; statement, with a
comma separating them.
 </t>
 <t>
All the components in the &quot;key&quot; statement MUST be encoded.
Partial instance identifiers are not supported.
 </t>
 <t>
Quoted strings are supported in the key leaf values. Quoted
strings MUST be used to express empty strings.
(example: list=foo,&apos;&apos;,baz).
 </t>
 <t>
The &quot;list&#8209;instance&quot; ABNF rule defined in <xref target="path-abnf"/>
represents the syntax of a list instance identifier.
 </t>
 <t>
Resource URI values returned in Location headers
for data resources MUST identify the module name, even
if there are no conflicting local names when the resource
is created. This ensures the correct resource will be identified
even if the server loads a new module that the old client
does not know about.
 </t>
 </list>
</t>
    <t>
Examples:
    </t>
	<figure>
	    <artwork><![CDATA[
   container top {
        list list1 {
        key "key1 key2 key3";
        ...
        list list2 {
            key "key4 key5";
            ...
            leaf X { type string; }
        }
    }
	    ]]></artwork>
	</figure>
    <t>
For the above YANG definition, URI with key leaf values will be
encoded as follows (line wrapped for display purposes only):
    </t>
	<figure>
	    <artwork><![CDATA[
    /restconf/data/top/list1=key1val,key2val,key3val3/
       list2=key4val,key5val/X
	    ]]></artwork>
	</figure>
<section title="ABNF For Data Resource Identifiers" anchor="path-abnf">
    <t>
The &quot;api&#8209;path&quot; ABNF syntax is used to construct RESTCONF
path identifiers:
    </t>
	<figure>
	    <artwork><![CDATA[
    api-path = "/"  |
               ("/" api-identifier
                 0*("/" (api-identifier | list-instance )))

    api-identifier = [module-name ":"] identifier

    module-name = identifier

    list-instance = api-identifier "=" key-value ["," key-value]*

    key-value = string

    string = <a quoted or unquoted or empty string>

    ;; An identifier MUST NOT start with
    ;; (('X'|'x') ('M'|'m') ('L'|'l'))
    identifier  = (ALPHA / "_")
                  *(ALPHA / DIGIT / "_" / "-" / ".")
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Defaults Handling">
    <t>
NETCONF has a rather complex model for handling default values for
leafs.  RESTCONF attempts to avoid this complexity by
restricting the operations that can be applied to
a resource.  Applications that require full control of defaults
might consider NETCONF instead of RESTCONF.
    </t>
    <t>
If the target of a GET method is a data node
that represents a leaf that has a default value,
and the leaf has not been given a value yet, the server MUST
return the default value that is in use by the server.
    </t>
    <t>
If the target of a GET method is a data node
that represents a container or list that has any child resources
with default values, for the child resources that have not been given
value yet, the server MAY
return the default values that are in use by the server.
    </t>
</section>
</section>
<section title="Operation Resource" anchor="operation-resource">
    <t>
An operation resource represents an protocol operation
defined with the YANG &quot;rpc&quot; statement.
    </t>
    <t>
All operation resources share the same module namespace
as any top-level data resources, so the name of an operation
resource cannot conflict with the name of a top-level
data resource defined within the same module.
    </t>
    <t>
If 2 different YANG modules define the same &quot;rpc&quot; identifier,
then the module name MUST be used in the request URI.
For example, if &quot;module&#8209;A&quot; and &quot;module&#8209;B&quot; both defined
a &quot;reset&quot; operation, then invoking the operation from &quot;module&#8209;A&quot;
would be requested as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/module-A:reset HTTP/1.1
   Server example.com
	    ]]></artwork>
	</figure>
    <t>
Any usage of an operation resource from the same module,
with the same name, refers to the same &quot;rpc&quot; statement
definition.  This behavior can be used to design protocol operations
that perform the same general function on different
resource types.
    </t>
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then a message body
MAY be sent by the client in the request, otherwise the request
message MUST NOT include a message body.
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then a message body
MAY be sent by the server in the response. Otherwise the
server MUST NOT include a message body in the response message,
and MUST send a &quot;204 No Content&quot; Status-Line instead.
    </t>
<section title="Encoding Operation Input Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;input&quot; section, then
the &quot;input&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;input&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc reboot {
      input {
        leaf delay {
          units seconds;
          type uint32;
          default 0;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:reboot HTTP/1.1
   Host: example.com
   Content-Type: application/yang.operation+json

   {
     "example-ops:input" : {
       "delay" : 600,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 25 Apr 2012 11:01:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="Encoding Operation Output Parameters">
    <t>
If the &quot;rpc&quot; statement has an &quot;output&quot; section, then
the &quot;output&quot; node is provided in the message body,
corresponding to the YANG data definition statements
within the &quot;output&quot; section.
    </t>
    <t>
Example:
    </t>
    <t>
The following YANG definition is used for the examples in this
section.
    </t>
	<figure>
	    <artwork><![CDATA[
    rpc get-reboot-info {
      output {
        leaf reboot-time {
          units seconds;
          type uint32;
        }
        leaf message { type string; }
        leaf language { type string; }
      }
    }
	    ]]></artwork>
	</figure>
    <t>
The client might send the following POST request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:get-reboot-info HTTP/1.1
   Host: example.com
   Accept: application/yang.operation+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 25 Apr 2012 11:10:30 GMT
   Server: example-server
   Content-Type: application/yang.operation+json

   {
     "example-ops:output" : {
       "reboot-time" : 30,
       "message" : "Going down for system maintenance",
       "language" : "en-US"
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Schema Resource" anchor="schema-resource">
    <t>
If the server supports the &quot;schema&quot; leaf within the API then
the client can retrieve the YANG schema text for the associated
YANG module or submodule, using the GET method.
    </t>
    <t>
The client might send the following GET request message:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/modules/module=example-jukebox,2014-07-03/schema
      HTTP/1.1
   Host: example.com
   Accept: application/yang,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 25 Apr 2012 11:10:30 GMT
   Server: example-server
   Content-Type: application/yang

   module example-jukebox {

      namespace "http://example.com/ns/example-jukebox";
      prefix "jbox";

      // rest of YANG module content deleted...
   }
	    ]]></artwork>
	</figure>
</section>
<section title="Stream Resource" anchor="stream-resource">
    <t>
A &quot;stream&quot; resource represents a source for system generated
event notifications.  Each stream is created and modified
by the server only.  A client can retrieve a stream resource
or initiate a long-poll server sent event stream,
using the procedure specified in <xref target="receive-notifs"/>.
    </t>
    <t>
A notification stream functions according to the NETCONF
Notifications specification <xref target="RFC5277"/>.  The &quot;ietf&#8209;restconf&quot;
YANG module contains the &quot;stream&quot; list (&quot;{+restconf}/streams/stream&quot;)
which specifies the syntax and semantics of a stream resource.
    </t>
</section>
<section title="Errors Resource" anchor="errors-resource">
    <t>
An &quot;errors&quot; resource is a collection of error information that
is sent as the message body in a server response message,
if an error occurs while processing a request message.
    </t>
    <t>
The &quot;ietf&#8209;restconf&quot; YANG module contains the &quot;errors&quot; grouping
which specifies the syntax and semantics of an errors resource.
RESTCONF error handling behavior is defined in <xref target="error-reporting"/>.
    </t>
</section>
</section>
<section title="Operations" anchor="operations">
    <t>
The RESTCONF protocol uses HTTP methods to identify
the CRUD operation requested for a particular resource.
    </t>
    <t>
The following table shows how the RESTCONF operations relate to
NETCONF protocol operations:
    </t>
<?rfc compact="yes"?><texttable anchor="table-crud-operations" title="CRUD Methods in RESTCONF">
<ttcol align='left'> RESTCONF</ttcol>
<ttcol align='left'>NETCONF</ttcol>
<c>OPTIONS</c>
<c>none</c>
<c>HEAD</c>
<c>none</c>
<c>GET</c>
<c>&lt;get-config&gt;, &lt;get&gt;</c>
<c>POST</c>
<c>&lt;edit-config&gt; (operation=&quot;create&quot;)</c>
<c>PUT</c>
<c>&lt;edit-config&gt; (operation=&quot;replace&quot;)</c>
<c>PATCH</c>
<c>&lt;edit-config&gt; (operation=&quot;merge&quot;)</c>
<c>DELETE</c>
<c>&lt;edit-config&gt; (operation=&quot;delete&quot;)</c>
</texttable>
<?rfc compact="no"?>    <t>
The NETCONF &quot;remove&quot; operation attribute is not supported
by the HTTP DELETE method. The resource must exist or
the DELETE method will fail. The PATCH method is equivalent to
a &quot;merge&quot; operation for a plain patch.
    </t>
    <t>
Access control mechanisms may be used to limit what operations
can be used.  In particular, RESTCONF is compatible with the
NETCONF Access Control Model (NACM) <xref target="RFC6536"/>, as there is a
specific mapping between RESTCONF and NETCONF operations,
defined in <xref target="table-crud-operations"/>.  The resource path needs
to be converted internally by the server to the corresponding
YANG instance-identifier.  Using this information,
the server can apply the NACM access control rules to RESTCONF
messages.
    </t>
    <t>
The server MUST NOT allow any operation to any resources that
the client is not authorized to access.
    </t>
    <t>
Implementation of all methods (except PATCH) are defined in <xref target="RFC2616"/>.
This section defines the RESTCONF protocol usage for
each HTTP method.
    </t>
<section title="OPTIONS" anchor="options">
    <t>
The OPTIONS method is sent by the client to
discover which methods are supported by the server
for a specific resource.
If supported, it SHOULD be implemented for all media types.
    </t>
    <t>
The server SHOULD implement this method, however the same information
could be extracted from the YANG modules and the RESTCONF
protocol specification.
    </t>
    <t>
If the PATCH method is supported, then the &quot;Accept&#8209;Patch&quot; header
MUST be supported, as defined in <xref target="RFC5789"/>.
    </t>
</section>
<section title="HEAD" anchor="head">
    <t>
The HEAD method is sent by the client to
retrieve just the headers that would be returned
for the comparable GET method, without the response body.
It is supported for all resource types, except operation resources.
    </t>
    <t>
The request MUST contain a request URI
that contains at least the entry point component.
The same query parameters supported by the GET method
are supported by the HEAD method.
    </t>
    <t>
The access control behavior is enforced
as if the method was GET instead of HEAD.
The server MUST respond the same as if the method
was GET instead of HEAD, except that no
response body is included.
    </t>
</section>
<section title="GET" anchor="get">
    <t>
The GET method is sent by the client to
retrieve data and meta-data for a resource.
It is supported for all resource types, except operation resources.
The request MUST contain a request URI
that contains at least the entry point component.
    </t>
    <t>
The server MUST NOT return any data resources for which the user
does not have read privileges.
If the user is not authorized to read
the target resource, an error response containing
a &quot;403 Forbidden&quot; or &quot;404 Not Found&quot; Status-Line is returned to
the client.
    </t>
    <t>
If the user is authorized to read some but not all of
the target resource, the unauthorized content is omitted
from the response message body, and the authorized content
is returned to the client.
    </t>
    <t>
Example:
    </t>
    <t>
The client might request the response headers for a
JSON representation of the &quot;library&quot; resource:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox/
     library/artist=Foo%20Fighters/album  HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:02:40 GMT
   Server: example-server
   Content-Type: application/yang.data+json
   Cache-Control: no-cache
   Pragma: no-cache
   ETag: a74eefc993a2b
   Last-Modified: Mon, 23 Apr 2012 11:02:14 GMT

   {
     "album" : [
       {
         "name" : "Wasting Light",
         "genre" : "example-jukebox:alternative",
         "year" : 2011
       }
     ]
   }
	    ]]></artwork>
	</figure>
</section>
<section title="POST" anchor="post">
    <t>
The POST method is sent by the client to create a data resource
or invoke an operation resource.
The server uses the target resource media type
to determine how to process the request.
    </t>
<?rfc compact="yes"?><texttable title="Resource Types that Support POST">
<ttcol align='left'> Type</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Datastore</c>
<c>Create a top-level configuration data resource</c>
<c>Data</c>
<c>Create a configuration data child resource</c>
<c>Operation</c>
<c>Invoke a protocol operation</c>
</texttable>
<?rfc compact="no"?><section title="Create Resource Mode">
    <t>
If the target resource type is a datastore or data resource,
then the POST is treated as a request to create a resource or
child resource.  The message body is expected to contain the
content of a child resource to create within the parent (target resource).
    </t>
    <t>
The &quot;insert&quot; and &quot;point&quot; query parameters are supported
by the POST method for datastore and data resource types,
as specified in the YANG definition in <xref target="module"/>.
    </t>
    <t>
If the POST method succeeds,
a &quot;201 Created&quot; Status-Line is returned and there is
no response message body.  A &quot;Location&quot; header identifying
the child resource that was created MUST be present
in the response in this case.
    </t>
    <t>
If the user is not authorized to create the target resource,
an error response containing
a &quot;403 Forbidden&quot; or &quot;404 Not Found&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
To create a new &quot;jukebox&quot; resource, the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/data HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   { "example-jukebox:jukebox" : [null] }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Location: http://example.com/restconf/data/example-jukebox:jukebox
   Last-Modified: Mon, 23 Apr 2012 17:01:00 GMT
   ETag: b3a3e673be2
	    ]]></artwork>
	</figure>
    <t>
Refer to <xref target="ex-create"/> for more resource creation examples.
    </t>
</section>
<section title="Invoke Operation Mode">
    <t>
If the target resource type is an operation resource,
then the POST method is treated as a request to invoke that operation.
The message body (if any) is processed as the operation input
parameters.  Refer to <xref target="operation-resource"/> for details
on operation resources.
    </t>
    <t>
If the POST request succeeds, a &quot;200 OK&quot; Status-Line
is returned if there is a response message body, and
a &quot;204 No Content&quot; Status-Line is returned if there is
no response message body.
    </t>
    <t>
If the user is not authorized to invoke the target operation,
an error response containing
a &quot;403 Forbidden&quot; or &quot;404 Not Found&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
In this example, the client is invoking the &quot;play&quot; operation
defined in the &quot;example&#8209;jukebox&quot; YANG module.
    </t>
    <t>
A client might send a &quot;play&quot; request as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-jukebox:play   HTTP/1.1
   Host: example.com
   Content-Type: application/yang.operation+json

   {
     "example-jukebox:input" : {
       "playlist" : "Foo-One",
       "song-number" : 2
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:50:00 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="PUT" anchor="put">
    <t>
The PUT method is sent by the client to create or replace
the target resource.
    </t>
    <t>
The only target resource media type that supports PUT is the data
resource. The message body is expected to contain the
content used to create or replace the target resource.
    </t>
    <t>
The &quot;insert&quot; and &quot;point&quot; query parameters are supported
by the PUT method for data resources,
as specified in the YANG definition in <xref target="module"/>.
    </t>
    <t>
Consistent with <xref target="RFC2616"/>, if the PUT request creates a new resource,
a &quot;201 Created&quot; Status-Line is returned.   If an existing resource
is modified, either &quot;200 OK&quot; or &quot;204 No Content&quot; are returned.
    </t>
    <t>
If the user is not authorized to create or replace the target resource
an error response containing
a &quot;403 Forbidden&quot; or &quot;404 Not Found&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
An &quot;album&quot; child resource defined in the &quot;example&#8209;jukebox&quot; YANG module
is replaced or created if it does not already exist.
    </t>
    <t>
To replace the &quot;album&quot; resource contents,
the client might send as follows.
Note that the request URI header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   PUT /restconf/data/example-jukebox:jukebox/
      library/artist=Foo%20Fighters/album=Wasting%20Light   HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:alternative",
       "year" : 2011
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:04:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:04:00 GMT
   ETag: b27480aeda4c
	    ]]></artwork>
	</figure>
</section>
<section title="PATCH" anchor="patch">
    <t>
RESTCONF uses the HTTP PATCH method defined
in <xref target="RFC5789"/> to provide an extensible framework for
resource patching mechanisms.  It is optional to implement
by the server.  Each patch type needs a unique
media type.  Zero or more PATCH media types MAY be supported
by the server.
    </t>
    <t>
A plain patch is used to create or update
a child resource within the target resource.
If the target resource instance does not exist, the server MUST
NOT create it.
    </t>
    <t>
If the PATCH request succeeds, a &quot;200 OK&quot; Status-Line
is returned if there is a message body, and &quot;204 No Content&quot;
is returned if no response message body is sent.
    </t>
    <t>
If the user is not authorized to alter the target resource
an error response containing
a &quot;403 Forbidden&quot; or &quot;404 Not Found&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
To replace just the &quot;year&quot; field in the &quot;album&quot; resource
(instead of replacing the entire resource with the PUT method),
the client might send a plain patch as follows.
Note that the request URI header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /restconf/data/example-jukebox:jukebox/
      library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:album" : {
       "genre" : "example-jukebox:rock",
       "year" : 2011
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the field is updated, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:30 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:49:30 GMT
   ETag: b2788923da4c
	    ]]></artwork>
	</figure>
    <t>
The XML encoding for the same request might be:
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /restconf/data/example-jukebox:jukebox/
      library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
   If-Match: b8389233a4c
   Content-Type: application/yang.data+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <album xmlns="http://example.com/ns/example-jukebox">
      <genre>example-jukebox:rock</genre>
      <year>2011</year>
   </album>
	    ]]></artwork>
	</figure>
</section>
<section title="DELETE" anchor="delete">
    <t>
The DELETE method is used to delete the target resource.
If the DELETE request succeeds, a &quot;204 No Content&quot; Status-Line
is returned, and there is no response message body.
    </t>
    <t>
If the user is not authorized to delete the target resource then
an error response containing
a &quot;403 Forbidden&quot; or &quot;404 Not Found&quot; Status-Line is returned to
the client.  All other error responses are handled according to
the procedures defined in <xref target="error-reporting"/>.
    </t>
    <t>
Example:
    </t>
    <t>
To delete a resource such as the &quot;album&quot; resource,
the client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   DELETE /restconf/data/example-jukebox:jukebox/
      library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
If the resource is deleted, the server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 17:49:40 GMT
   Server: example-server
	    ]]></artwork>
	</figure>
</section>
<section title="Query Parameters" anchor="query-parameters">
    <t>
Each RESTCONF operation allows zero or more query
parameters to be present in the request URI.
The specific parameters that are allowed depends
on the resource type, and sometimes the specific target
resource used, in the request.
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Methods</ttcol>
<ttcol align='left'>Description</ttcol>
<c>content</c>
<c>GET</c>
<c>Select config and/or non-config data resources</c>
<c>depth</c>
<c>GET</c>
<c>Request limited sub-tree depth in the reply content</c>
<c>filter</c>
<c>GET</c>
<c>Boolean notification filter for event-stream resources</c>
<c>insert</c>
<c>POST, PUT</c>
<c>Insertion mode for user-ordered data resources</c>
<c>point</c>
<c>POST, PUT</c>
<c>Insertion point for user-ordered data resources</c>
<c>select</c>
<c>GET</c>
<c>Request a subset of the target resource contents</c>
<c>start-time</c>
<c>GET</c>
<c>Replay buffer start time for event-stream resources</c>
<c>stop-time</c>
<c>GET</c>
<c>Replay buffer stop time for event-stream resources</c>
</texttable>
<?rfc compact="no"?>    <t>
Query parameters can be given in any order.
Each parameter can appear at most once in a request URI.
A default value may apply if the parameter is missing.
    </t>
    <t>
The semantics and syntax for all query parameters are
defined in the &quot;query&#8209;parameters&quot; YANG grouping in <xref target="module"/>.
The YANG encoding MUST be converted to URL-encoded string
for use in the request URI.
    </t>
    <t>
Refer to <xref target="ex-query"/> for examples of query parameter usage.
    </t>
</section>
</section>
<section title="Messages" anchor="messages">
    <t>
The RESTCONF protocol uses HTTP entities for messages.
A single HTTP message corresponds to a single protocol method.
Most messages can perform a single task on a single resource,
such as retrieving a resource or editing a resource.
The exception is the PATCH method, which allows multiple datastore
edits within a single message.
    </t>
<section title="Request URI Structure">
    <t>
Resources are represented with URIs following the structure
for generic URIs in <xref target="RFC3986"/>.
    </t>
    <t>
A RESTCONF operation is derived from the HTTP method
and the request URI, using the following conceptual fields:
    </t>
	<figure>
	    <artwork><![CDATA[
     <OP> /<restconf>/<path>?<query>#<fragment>
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
      ^       ^        ^       ^         ^
      |       |        |       |         |
    method  entry  resource  query    fragment

      M       M        O        O         I

    M=mandatory, O=optional, I=ignored
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
    <text> replaced by client with real values
	    ]]></artwork>
	</figure>
<t>
 <list style="symbols">
 <t>
method: the HTTP method identifying the RESTCONF operation
requested by the client, to act upon the target resource
specified in the request URI.  RESTCONF operation details are
described in <xref target="operations"/>.
 </t>
 <t>
entry: the root of the RESTCONF API configured on this HTTP
server, discovered by getting the &quot;.well&#8209;known/host&#8209;meta&quot;
resource, as described in <xref target="path-resolution"/>.  All
of the examples in this document assume &quot;/restconf&quot; as the
discovered RESTCONF API root path.  The URI template <xref target="RFC6570"/>
syntax &quot;{+restconf}&quot; is used to refer to the entry point
outside of an example.
 </t>
 <t>
resource: the path expression identifying the resource
that is being accessed by the operation.
If this field is not present, then the target resource
is the API itself, represented by the media type &quot;application/yang.api&quot;.
 </t>
 <t>
query: the set of parameters associated with the RESTCONF
message. These have the familiar form of &quot;name=value&quot; pairs.
There is a specific set of parameters defined,
although the server MAY choose to support additional
parameters not defined in this document.
The contents of the any query parameter value MUST be encoded
according to <xref target="RFC2396"/>, section 3.4. Any reserved characters
MUST be encoded with escape sequences, according to <xref target="RFC2396"/>,
section 2.4.
 </t>
 <t>
fragment: This field is not used by the RESTCONF protocol.
 </t>
 </list>
</t>
    <t>
When new resources are created by the client, a &quot;Location&quot; header
is returned, which identifies the path of the newly created resource.
The client MUST use this exact path identifier to access
the resource once it has been created.
    </t>
    <t>
The &quot;target&quot; of an operation is a resource.
The &quot;path&quot; field in the request URI represents
the target resource for the operation.
    </t>
</section>
<section title="RESTCONF Path Resolution" anchor="path-resolution">
    <t>
In line the best practices defined by <xref target="get-off-my-lawn"/>, RESTCONF
enables deployments to specify where the RESTCONF API is located.
When first connecting to a RESTCONF server, a RESTCONF client MUST
determine the root of the RESTCONF API.  The client discovers this
by getting the &quot;/.well&#8209;known/host&#8209;meta&quot; resource (<xref target="RFC6415"/>) and
using the &lt;Link&gt; element containing the &quot;restconf&quot; attribute :
    </t>
	<figure>
	    <artwork><![CDATA[
   Request
   -------
   GET /.well-known/host-meta users HTTP/1.1
   Host: example.com
   Accept: application/xrd+xml

   Response
   --------
   HTTP/1.1 200 OK
   Content-Type: application/xrd+xml
   Content-Length: nnn
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <XRD xmlns='http://docs.oasis-open.org/ns/xri/xrd-1.0'>
       <Link rel='restconf' href='/restconf'/>
   </XRD>
	    ]]></artwork>
	</figure>
    <t>
Once discovering the RESTCONF API root, the client MUST prepend it to
any subsequent request to a RESTCONF resource.  For instance, using
the &quot;/restconf&quot; path discovered above, the client can now determine
the operations supported by the the server:
    </t>
	<figure>
	    <artwork><![CDATA[
   Request
   -------
   GET /restconf/operations  HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json,
           application/yang.errors+json

   Response
   --------
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
   Content-Type: application/yang.api+json

   { "operations" : { "play" : [ null ] } }
	    ]]></artwork>
	</figure>
</section>
<section title="Message Headers">
    <t>
There are several HTTP header lines utilized in RESTCONF messages.
Messages are not limited to the HTTP headers listed in this section.
    </t>
    <t>
HTTP defines which header lines are required for particular
circumstances. Refer to each operation definition section
in <xref target="operations"/> for examples on how particular headers are used.
    </t>
    <t>
There are some request headers that are used within RESTCONF,
usually applied to data resources.
The following tables summarize the headers most relevant
in RESTCONF message requests:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Request Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Accept</c>
<c>Response Content-Types that are acceptable</c>
<c>Content-Type</c>
<c>The media type of the request body</c>
<c>Host</c>
<c>The host address of the server</c>
<c>If-Match</c>
<c>Only perform the action if the entity matches ETag</c>
<c>If-Modified-Since</c>
<c>Only perform the action if modified since time</c>
<c>If-Unmodified-Since</c>
<c>Only perform the action if un-modified since time</c>
</texttable>
<?rfc compact="no"?>    <t>
The following tables summarize the headers most relevant
in RESTCONF message responses:
    </t>
<?rfc compact="yes"?><texttable title="RESTCONF Response Headers">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>Allow</c>
<c>Valid actions when 405 error returned</c>
<c>Cache-Control</c>
<c>The cache control parameters for the response</c>
<c>Content-Type</c>
<c>The media type of the response body</c>
<c>Date</c>
<c>The date and time the message was sent</c>
<c>ETag</c>
<c>An identifier for a specific version of a resource</c>
<c>Last-Modified</c>
<c>The last modified date and time of a resource</c>
<c>Location</c>
<c>The resource identifier for a newly created resource</c>
</texttable>
<?rfc compact="no"?></section>
<section title="Message Encoding">
    <t>
RESTCONF messages are encoded in HTTP according to RFC 2616.
The &quot;utf&#8209;8&quot; character set is used for all messages.
RESTCONF message content is sent in the HTTP message body.
    </t>
    <t>
Content is encoded in either JSON or XML format.
    </t>
    <t>
XML encoding rules for data nodes are defined in <xref target="RFC6020"/>.
The same encoding rules are used for all XML content.
    </t>
    <t>
JSON encoding rules are defined in <xref target="I-D.lhotka-netmod-json"/>.
This encoding is valid JSON, but also has
special encoding rules to identify module namespaces
and provide consistent type processing of YANG data.
    </t>
    <t>
Request input content encoding format is identified with the Content-Type
header.  This field MUST be present if a message body is sent
by the client.
    </t>
    <t>
Response output content encoding format is identified with the Accept
header in the request, or if is not specified, the request
input encoding format is used.
If there was no request input, then the default output encoding is XML.
File extensions encoded in the request are not used to identify
format encoding.
    </t>
</section>
<section title="RESTCONF Meta-Data">
    <t>
The RESTCONF protocol needs to retrieve the same meta-data that is
used in the NETCONF protocol.  Information about default leafs,
last-modified timestamps, etc. are commonly used to annotate
representations of the datastore contents.  This meta-data
is not defined in the YANG schema because it applies to the
datastore, and is common across all data nodes.
    </t>
    <t>
This information is encoded as attributes in XML.
JSON encoding of meta-data is defined in <xref target="I-D.lhotka-netmod-json"/>.
    </t>
</section>
<section title="Return Status">
    <t>
Each message represents some sort of resource access.
An HTTP &quot;Status&#8209;Line&quot; header line is returned for each request.
If a 4xx or 5xx range status code is returned in the Status-Line,
then the error information will be returned in the response,
according to the format defined in <xref target="errors"/>.
    </t>
</section>
<section title="Message Caching">
    <t>
Since the datastore contents change at unpredictable times,
responses from a RESTCONF server generally SHOULD NOT be cached.
    </t>
    <t>
The server SHOULD include a &quot;Cache&#8209;Control&quot; header in every response
that specifies whether the response should be cached.  A &quot;Pragma&quot;
header specifying &quot;no&#8209;cache&quot; MAY also be sent in case the
&quot;Cache&#8209;Control&quot; header is not supported.
    </t>
    <t>
Instead of using HTTP caching, the client SHOULD track the &quot;ETag&quot;
and/or &quot;Last&#8209;Modified&quot; headers returned by the server for the
datastore resource (or data resource if the server supports it).
A retrieval request for a resource can include
the &quot;If&#8209;None&#8209;Match&quot; and/or &quot;If&#8209;Modified&#8209;Since&quot; headers, which
will cause the server to return a &quot;304 Not Modified&quot; Status-Line
if the resource has not changed.
The client MAY use the HEAD method to retrieve just
the message headers, which SHOULD include the &quot;ETag&quot;
and &quot;Last&#8209;Modified&quot; headers, if this meta-data is maintained
for the target resource.
    </t>
</section>
</section>
<section title="Notifications" anchor="notifications">
    <t>
The RESTCONF protocol supports YANG-defined event notifications.
The solution preserves aspects of NETCONF Event Notifications <xref target="RFC5277"/>
while utilizing the Server-Sent Events <xref target="wd-eventsource"/> transport strategy.
    </t>
<section title="Server Support">
    <t>
A RESTCONF server is not required to support RESTCONF notifications.
Clients may determine if a server supports RESTCONF notifications by
using the HTTP operation OPTIONS, HEAD, or GET on the
&quot;{+restconf}/streams&quot; resource described below.
The server does not support RESTCONF notifications if an HTTP error
code is returned (e.g., 404 Not Found).
    </t>
</section>
<section title="Event Streams">
    <t>
A RESTCONF server that supports notifications will populate a
stream resource for each notification delivery service access point.
A RESTCONF client can retrieve the list of supported event streams from
a RESTCONF server using the GET operation on the &quot;{+restconf}/streams&quot;
resource.
    </t>
    <t>
The &quot;{+restconf}/streams&quot; container definition in the &quot;ietf&#8209;restconf&quot; module
defined in <xref target="module"/> is used to specify the structure and syntax
of the conceptual child resources within the &quot;streams&quot; resource.
    </t>
    <t>
For example:
    </t>
    <t>
The client might send the following request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams HTTP/1.1
   Host: example.com
   Accept: application/yang.api+xml,
           application/yang.errors+xml
	    ]]></artwork>
	</figure>
    <t>
The server might send the following response:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/yang.api+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <streams xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
      <stream>
         <name>NETCONF</name>
         <description>default NETCONF event stream
         </description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-08T00:00:00Z
         </replay-log-creation-time>
         <events/>
      </stream>
      <stream>
         <name>SNMP</name>
         <description>SNMP notifications</description>
         <replay-support>false</replay-support>
         <events/>
      </stream>
      <stream>
         <name>syslog-critical</name>
         <description>Critical and higher severity
         </description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-01T00:00:00Z
         </replay-log-creation-time>
         <events/>
      </stream>
   </streams>
	    ]]></artwork>
	</figure>
</section>
<section title="Subscribing to Receive Notifications" anchor="receive-notifs">
    <t>
RESTCONF clients can subscribe to receive notifications by sending an
HTTP GET request for the &quot;{+restconf}/streams/stream/&lt;stream&#8209;name&gt;&quot; resource,
with the &quot;Accept&quot; type &quot;text/event&#8209;stream&quot;.
The server will treat the connection as an event stream, using the
Server Sent Events <xref target="wd-eventsource"/> transport strategy.
    </t>
    <t>
The server MAY support query parameters for a GET method on this
resource.  These parameters are specific to each notification stream.
    </t>
    <t>
For example:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams/stream=NETCONF/events HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
	    ]]></artwork>
	</figure>
    <t>
A RESTCONF client MAY request the server compress the events using
the HTTP header field &quot;Accept&#8209;Encoding&quot;.  For instance:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/streams/stream=NETCONF/events HTTP/1.1
   Host: example.com
   Accept: text/event-stream
   Cache-Control: no-cache
   Connection: keep-alive
   Accept-Encoding: gzip, deflate
	    ]]></artwork>
	</figure>
<section title="NETCONF Event Stream">
    <t>
The server SHOULD support the &quot;NETCONF&quot; notification stream
defined in <xref target="RFC5277"/>.  For this stream,
RESTCONF notification subscription requests MAY specify parameters
indicating the events it wishes to receive.
    </t>
<?rfc compact="yes"?><texttable title="NETCONF Stream Query Parameters">
<ttcol align='left'> Name</ttcol>
<ttcol align='left'>Description</ttcol>
<c>start-time</c>
<c>replay event start time</c>
<c>stop-time</c>
<c>replay event stop time</c>
<c>filter</c>
<c>boolean content filter</c>
</texttable>
<?rfc compact="no"?>    <t>
The semantics and syntax for these query parameters are
defined in the &quot;query&#8209;parameters&quot; YANG grouping in <xref target="module"/>.
The YANG encoding MUST be converted to URL-encoded string
for use in the request URI.
    </t>
    <t>
Refer to <xref target="ex-filters"/> for filter parameter examples.
    </t>
</section>
</section>
<section title="Receiving Event Notifications">
    <t>
RESTCONF notifications are encoded according to the
definition of the event stream.  The NETCONF stream
defined in <xref target="RFC5277"/> is encoded in XML format.
    </t>
    <t>
The structure of the event data is based on the &quot;notification&quot;
element definition in section 4 of <xref target="RFC5277"/>. It MUST
conform to the &quot;notification&quot; YANG container definition in <xref target="module"/>.
    </t>
    <t>
An example SSE notification encoded using XML:
    </t>
	<figure>
	    <artwork><![CDATA[
   data: <notification
   data:    xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
   data:    <event-time>2013-12-21T00:01:00Z</event-time>
   data:    <event xmlns="http://example.com/event/1.0">
   data:       <eventClass>fault</eventClass>
   data:       <reportingEntity>
   data:           <card>Ethernet0</card>
   data:       </reportingEntity>
   data:       <severity>major</severity>
   data:     </event>
   data: </notification>
	    ]]></artwork>
	</figure>
    <t>
Since XML is not whitespace sensitive,
the above message can be encoded onto a single line.
    </t>
    <t>
For example:  (&apos;\&apos; line wrapping added for formatting only)
    </t>
	<figure>
	    <artwork><![CDATA[
   data: <notification xmlns="urn:ietf:params:xml:ns:yang:ietf-rest\
   conf"><event-time>2013-12-21T00:01:00Z</event-time><event xmlns="\
   http://example.com/event/1.0"><eventClass>fault</eventClass><repo\
   rtingEntity><card>Ethernet0</card></reportingEntity><severity>maj\
   or</severity></event></notification>
	    ]]></artwork>
	</figure>
    <t>
The SSE specifications supports the following additional fields:
event, id and retry.  A RESTCONF server MAY send the &quot;retry&quot; field
and, if it does, RESTCONF clients SHOULD use it.
A RESTCONF server SHOULD NOT send the &quot;event&quot; or &quot;id&quot; fields,
as there are no meaningful values that could be used for them
that would not be redundant to the contents of the notification itself.
RESTCONF servers that do not send the &quot;id&quot; field also do not need
to support the HTTP header &quot;Last&#8209;Event&#8209;Id&quot;.  RESTCONF servers that
do send the &quot;id&quot; field MUST still support the &quot;startTime&quot; query
parameter as the preferred means for a client to specify where to
restart the event stream.
    </t>
</section>
</section>
<section title="Error Reporting" anchor="error-reporting">
    <t>
HTTP Status-Lines are used to report success or failure
for RESTCONF operations.
The &lt;rpc&#8209;error&gt; element returned in NETCONF error responses
contains some useful information.  This error information
is adapted for use in RESTCONF, and error information
is returned for &quot;4xx&quot; class of status codes.
    </t>
    <t>
The following table summarizes the return status codes
used specifically by RESTCONF operations:
    </t>
<?rfc compact="yes"?><texttable title="HTTP Status Codes used in RESTCONF">
<ttcol align='left'> Status-Line</ttcol>
<ttcol align='left'>Description</ttcol>
<c>100 Continue</c>
<c>POST accepted, 201 should follow</c>
<c>200 OK</c>
<c>Success with response body</c>
<c>201 Created</c>
<c>POST to create a resource success</c>
<c>202 Accepted</c>
<c>POST to create a resource accepted</c>
<c>204 No Content</c>
<c>Success without response body</c>
<c>304 Not Modified</c>
<c>Conditional operation not done</c>
<c>400 Bad Request</c>
<c>Invalid request message</c>
<c>403 Forbidden</c>
<c>Access to resource denied</c>
<c>404 Not Found</c>
<c>Resource target or resource node not found</c>
<c>405 Method Not Allowed</c>
<c>Method not allowed for target resource</c>
<c>409 Conflict</c>
<c>Resource or lock in use</c>
<c>412 Precondition Failed</c>
<c>Conditional method is false</c>
<c>413 Request Entity Too Large</c>
<c>too-big error</c>
<c>414 Request-URI Too Large</c>
<c>too-big error</c>
<c>415 Unsupported Media Type</c>
<c>non RESTCONF media type</c>
<c>500 Internal Server Error</c>
<c>operation-failed</c>
<c>501 Not Implemented</c>
<c>unknown-operation</c>
<c>503 Service Unavailable</c>
<c>Recoverable server error</c>
</texttable>
<?rfc compact="no"?>    <t>
Since an operation resource is defined with a YANG &quot;rpc&quot;
statement, a mapping between the NETCONF &lt;error&#8209;tag&gt; value
and the HTTP status code is needed.   The specific error
condition and response code to use are data-model specific
and might be contained in the YANG &quot;description&quot; statement
for the &quot;rpc&quot; statement.
    </t>
<?rfc compact="yes"?><texttable title="Mapping from error-tag to status code">
<ttcol align='left'> &lt;error&#8209;tag&gt;</ttcol>
<ttcol align='left'>status code</ttcol>
<c>in-use</c>
<c>409</c>
<c>invalid-value</c>
<c>400</c>
<c>too-big</c>
<c>413</c>
<c>missing-attribute</c>
<c>400</c>
<c>bad-attribute</c>
<c>400</c>
<c>unknown-attribute</c>
<c>400</c>
<c>bad-element</c>
<c>400</c>
<c>unknown-element</c>
<c>400</c>
<c>unknown-namespace</c>
<c>400</c>
<c>access-denied</c>
<c>403</c>
<c>lock-denied</c>
<c>409</c>
<c>resource-denied</c>
<c>409</c>
<c>rollback-failed</c>
<c>500</c>
<c>data-exists</c>
<c>409</c>
<c>data-missing</c>
<c>409</c>
<c>operation-not-supported</c>
<c>501</c>
<c>operation-failed</c>
<c>500</c>
<c>partial-operation</c>
<c>500</c>
<c>malformed-message</c>
<c>400</c>
</texttable>
<?rfc compact="no"?><section title="Error Response Message" anchor="errors">
    <t>
When an error occurs for a request message on a data resource
or an operation resource, and a &quot;4xx&quot; class of status codes
(except for status code &quot;403 Forbidden&quot;),
then the server SHOULD send a response body containing
the information described by the &quot;errors&quot; container definition
within the YANG module <xref target="module"/>.  The Content-Type of this
response message MUST be application/yang.errors.
    </t>
    <t>
YANG Tree Diagram for &lt;errors&gt; Data:
    </t>
	<figure>
	    <artwork><![CDATA[
   +--ro errors
      +--ro error
         +--ro error-type       enumeration
         +--ro error-tag        string
         +--ro error-app-tag?   string
         +--ro (error-node)?
         |  +--:(error-path)
         |  |  +--ro error-path?      instance-identifier
         |  +--:(error-urlpath)
         |     +--ro error-urlpath?   data-resource-identifier
         +--ro error-message?   string
         +--ro error-info
	    ]]></artwork>
	</figure>
    <t>
The semantics and syntax for RESTCONF error messages are
defined in the &quot;errors&quot; YANG grouping in <xref target="module"/>.
    </t>
    <t>
Examples:
    </t>
    <t>
The following example shows an error returned for
an &quot;lock&#8209;denied&quot; error on a datastore resource.
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/operations/example-ops:lock-datastore HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 17:11:00 GMT
   Server: example-server
   Content-Type: application/yang.errors+json

   {
     "ietf-restconf:errors": {
       "error": {
         "error-type": "protocol",
         "error-tag": "lock-denied",
         "error-message": "Lock failed, lock already held"
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
The following example shows an error returned for
a &quot;data&#8209;exists&quot; error on a data resource.
The &quot;jukebox&quot; resource already exists so it cannot be created.
    </t>
    <t>
The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox HTTP/1.1
   Host: example.com
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 409 Conflict
   Date: Mon, 23 Apr 2012 17:11:00 GMT
   Server: example-server
   Content-Type: application/yang.errors+json

   {
     "ietf-restconf:errors": {
       "error": {
         "error-type": "protocol",
         "error-tag": "data-exists",
         "error-urlpath": "http://example.com/restconf/data/
              example-jukebox:jukebox",
         "error-message":
           "Data already exists, cannot create new resource"
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="RESTCONF module" anchor="module">
    <t>
The &quot;ietf&#8209;restconf&quot; module defines conceptual definitions
within groupings, which are not meant to be implemented
as datastore contents by a server.
    </t>
    <t>
The &quot;ietf&#8209;yang&#8209;types&quot; and &quot;ietf&#8209;inet&#8209;types&quot; modules from <xref target="RFC6991"/>
are used by this module for some type definitions.
    </t>
    <t>
RFC Ed.: update the date below with the date of RFC publication and
remove this note.
    </t>
<t>&lt;CODE BEGINS> file "ietf-restconf@2014-07-03.yang"</t>
	<figure>
	    <artwork><![CDATA[
module ietf-restconf {
  namespace "urn:ietf:params:xml:ns:yang:ietf-restconf";
  prefix "rc";

  import ietf-yang-types { prefix yang; }
  import ietf-inet-types { prefix inet; }

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "WG Web:   <http://tools.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     WG Chair: Bert Wijnen
               <mailto:bertietf@bwijnen.net>

     WG Chair: Mehmet Ersue
               <mailto:mehmet.ersue@nsn.com>

     Editor:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Editor:   Kent Watsen
               <mailto:kwatsen@juniper.net>

     Editor:   Rex Fernando
               <mailto:rex@cisco.com>";

  description
    "This module contains conceptual YANG specifications
     for the message and error content that is used in
     RESTCONF protocol messages. A conceptual container
     representing the RESTCONF API nodes is also defined
     for the media type application/yang.api.

     Note that the YANG definitions within this module do not
     represent configuration data of any kind.
     The YANG grouping statements provide a normative syntax
     for XML and JSON message encoding purposes.

     Copyright (c) 2014 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";

  // RFC Ed.: replace XXXX with actual RFC number and remove this
  // note.

  // RFC Ed.: remove this note
  // Note: extracted from draft-ietf-netconf-restconf-01.txt

  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  revision 2014-07-03 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: RESTCONF Protocol.";
  }

  typedef data-resource-identifier {
    type string {
      length "1 .. max";
    }
    description
      "Contains a Data Resource Identifier formatted string
       to identify a specific data resource instance.
       The document root for all data resources is a
       datastore resource container. Each top-level YANG
       data nodes supported by the server will be represented
       as a child node of the document root.

       The canonical representation of a data resource identifier
       includes the full server specification that is returned
       in the Location header when a new data resource is created
       with the POST method.

       The abbreviated representation does not contain any server
       location identification. Instead the identifier will start
       with the '/' character to represent the datastore document
       root for the data resource instance.

       The server MUST accept either representation and SHOULD
       return the canonical representation in any response message.";
    reference
      "RFC XXXX: [sec. 5.3.1.1 ABNF For Data Resource Identifiers]";
  }

  typedef revision-identifier {
    type string {
      pattern '\d{4}-\d{2}-\d{2}';
    }
    description
      "Represents a specific date in YYYY-MM-DD format.
       TBD: make pattern more precise to exclude leading zeros.";
  }

  grouping errors {

    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of a
       YANG Patch errors report within a response message.";

    container errors {
      description
        "Represents an error report returned by the server if
         a request results in an error.";

      list error {
        description
          "An entry containing information about one
           specific error that occurred while processing
           a RESTCONF request.";
        reference "RFC 6241, Section 4.3";

        leaf error-type {
          type enumeration {
            enum transport {
              description "The transport layer";
            }
            enum rpc {
              description "The rpc or notification layer";
            }
            enum protocol {
              description "The protocol operation layer";
            }
            enum application {
              description "The server application layer";
            }
          }
          mandatory true;
          description
            "The protocol layer where the error occurred.";
        }

        leaf error-tag {
          type string;
          mandatory true;
          description
            "The enumerated error tag.";
        }

        leaf error-app-tag {
          type string;
          description
            "The application-specific error tag.";
        }

        choice error-node {
          description
            "The server will return the location of the error node
             in a format that is appropriate for the protocol.
             If no specific node within the request message body
             caused the error then this choice will not be present.";

          leaf error-path {
            type instance-identifier;
            description
              "The YANG instance identifier associated
               with the error node. This leaf will only be
               present if the error node is not a data resource,
               e.g., the error node is an input parameter
               for an operation resource.";
          }
          leaf error-urlpath {
            type data-resource-identifier;
            description
              "The target data resource identifier associated
               with the error node.  This leaf will only be
               present if the error node is associated with
               a data resource (either within the server or
               in the request message).";
          }
        }

        leaf error-message {
          type string;
          description
            "A message describing the error.";
        }

        anyxml error-info {
           description
             "Arbitrary XML that represents a container
              of additional information for the error report.";
        }
      }
    }
  } // grouping errors


  grouping restconf {
    description
      "A grouping that contains a YANG container
       representing the syntax and semantics of
       the RESTCONF API resource.";

    container restconf {
      description
        "Conceptual container representing the
         application/yang.api resource type.";

      container data {
        description
          "Container representing the application/yang.datastore
           resource type. Represents the conceptual root of all
           operational data and configuration data supported by
           the server.  The child nodes of this container can be
           any data resource (application/yang.data), which are
           defined as top-level data nodes from the YANG modules
           advertised by the server in /restconf/modules.";
      }

      container modules {
        description
          "Contains a list of module description entries.
           These modules are currently loaded into the server.";

        grouping common-leafs {
          description
            "Common parameters for YANG modules and submodules.";

          leaf name {
            type yang:yang-identifier;
            description "The YANG module or submodule name.";
          }
          leaf revision {
            type union {
              type revision-identifier;
              type string { length 0; }
            }
            description
              "The YANG module or submodule revision date.
               An empty string is used if no revision statement
               is present in the YANG module or submodule.";
          }

          leaf schema {
            type empty;
            description
              "Represents the YANG schema resource for this module
               or submodule if it is available on the server.
               This leaf will only be present if the server has
               the schema available for retrieval.  A GET
               request with a target resource URI that identifies
               this leaf will cause the server to return the YANG
               schema text for the associated module or submodule.";
          }
        }


        list module {
          key "name revision";
          description
            "Each entry represents one module currently
             supported by the server.";

          uses common-leafs;

          leaf namespace {
            type inet:uri;
            mandatory true;
            description
              "The XML namespace identifier for this module.";
          }
          leaf-list feature {
            type yang:yang-identifier;
            description
              "List of YANG feature names from this module that are
               supported by the server.";
          }
          leaf-list deviation {
            type yang:yang-identifier;
            description
              "List of YANG deviation module names used by this
               server to modify the conformance of the module
               associated with this entry.";
          }

          list submodule {
            key "name revision";
            description
              "Each entry represents one submodule within the
               parent module.";

            uses common-leafs;
          }
        }
      }

      container operations {
        description
          "Container for all operation resources
           (application/yang.operation),

           Each resource is represented as an empty leaf with the
           name of the RPC operation from the YANG rpc statement.

           E.g.;

              POST /restconf/operations/show-log-errors

              leaf show-log-errors {
                type empty;
              }
          ";
      }

      container streams {
        description
          "Container representing the notification event streams
           supported by the server.";
         reference
           "RFC 5277, Section 3.4, <streams> element.";

        list stream {
          key name;
          description
            "Each entry describes an event stream supported by
             the server.";

          leaf name {
            type string;
            description "The stream name";
            reference "RFC 5277, Section 3.4, <name> element.";
          }

          leaf description {
            type string;
            description "Description of stream content";
            reference
              "RFC 5277, Section 3.4, <description> element.";
          }

          leaf replay-support {
            type boolean;
            description
              "Indicates if replay buffer supported for this stream";
            reference
              "RFC 5277, Section 3.4, <replaySupport> element.";
          }

          leaf replay-log-creation-time {
            type yang:date-and-time;
            description
              "Indicates the time the replay log for this stream
               was created.";
            reference
              "RFC 5277, Section 3.4, <replayLogCreationTime>
               element.";
          }

          leaf events {
            type empty;
            description
              "Represents the entry point for establishing
               notification delivery via server sent events.";
          }
        }
      }

    }
  }  // grouping restconf


  grouping query-parameters {
    description
       "Contains conceptual definitions for the query string
        parameters used in the RESTCONF protocol.";

    leaf content {
      type enumeration {
        enum config {
          description
            "Return only configuration descendant data nodes";
        }
        enum nonconfig {
          description
            "Return only non-configuration descendant data nodes";
        }
        enum all {
          description
            "Return all descendant data nodes";
        }
      }
      description
         "The content parameter controls how descendant nodes of
          the requested data nodes will be processed in the reply.

          This parameter is only allowed for GET methods on
          datastore and data resources.  A 400 Bad Request error
          is returned if used for other methods or resource types.

          The default value is determined by the config-stmt
          value of the requested data nodes. If 'false', then
          the default is 'nonconfig'.  If 'true' then the
          default is 'config'.";
    }

    leaf depth {
      type union {
        type enumeration {
          enum unbounded {
            description "All sub-resources will be returned.";
          }
        }
        type uint32 {
          range "1..max";
        }
      }
      default unbounded;
      description
        "The 'depth' parameter is used to specify the number
         of nest levels returned in a response for a GET method.
         The first nest-level consists of the requested data node
         itself. Any child nodes which are contained within
         a parent node have a depth value that is 1 greater than
         its parent.

         This parameter is only allowed for GET methods on api,
         datastore, and data resources.  A 400 Bad Request error
         is returned if used for other methods or resource types.

         By default, the server will include all sub-resources
         within a retrieved resource, which have the same resource
         type as the requested resource. Only one level of
         sub-resources with a different media type than the target
         resource will be returned.";
    }

    leaf filter {
      type yang:xpath1.0;
      description
        "The 'filter' parameter is used to indicate which subset of
         all possible events are of interest.  If not present, all
         events not precluded by other parameters will be sent.

         This parameter is only allowed for GET methods on a
         text/event-stream data resource.  A 400 Bad Request error
         is returned if used for other methods or resource types.

         The format of this parameter is an XPath expression, and
         is evaluated in the following context:

         o  The set of namespace declarations is the set of
            prefix and namespace pairs for all supported YANG
            modules, where the prefix is the YANG module name, and
            the namespace is as defined by the 'namespace' statement
            in the YANG module.
         o  The function library is the core function library defined
            in XPATH.

         o  The set of variable bindings is empty.

         o  The context node is the root node

        The filter is used as defined in [RFC5277], section 3.6.
        If the boolean result of the expression is true when applied
        to the conceptual 'notification' document root, then the
        notification event is delivered to the client.";
    }

    leaf insert {
      type enumeration {
        enum first {
          description "Insert the new data as the new first entry.";
        }
        enum last {
          description "Insert the new data as the new last entry.";
        }
        enum before {
          description
            "Insert the new data before the insertion point,
             specified by the value of the 'point' parameter.";
        }
        enum after {
          description
            "Insert the new data after the insertion point,
             specified by the value of the 'point' parameter.";
        }
      }
      default last;
      description
        "The 'insert' parameter is used to specify how a
         resource should be inserted within a user-ordered list.

         This parameter is only supported for the POST and PUT
         methods. It is also only supported if the target
         resource is a data resource, and that data represents
         a YANG list or leaf-list that is ordered by the user.

         If the values 'before' or 'after' are used,
         then a 'point' query parameter for the insertion
         parameter MUST also be present, or a 400 Bad Request
         error is returned.";
    }

    leaf point {
      type data-resource-identifier;
      description
        "The 'point' parameter is used to specify the
         insertion point for a data resource that is being
         created or moved within a user ordered list or leaf-list.

         This parameter is only supported for the POST and PUT
         methods. It is also only supported if the target
         resource is a data resource, and that data represents
         a YANG list or leaf-list that is ordered by the user.

         If the 'insert' query parameter is not present, or has
         a value other than 'before' or 'after', then a 400
         Bad Request error is returned.

         This parameter contains the instance identifier of the
         resource to be used as the insertion point for a
         POST or PUT method.";
    }

    leaf select {
      type string {
        length "1 .. max";
      }
      description
        "The 'select' query parameter is used to optionally identify
         data nodes within the target resource to be retrieved in a
         GET method.  The client can use this parameter to retrieve
         a subset of all nodes in a resource.

         A value of the 'select' query parameter matches the
         following rule:

           select-expr = path '(' select-expr / '*' ')' /
                         path ';' select-expr /
                         path
           path = api-identifier [ '/' path ]

         'api-identifier' is defined in section 5.3.1.1.

         ';' is used to select multiple nodes.  For example, to
         retreive only the 'genre' and 'year' of an album, use:
         'select=genre;year'.

         Parentheses are used to specify sub-selectors of a node.
         For example, to retreive only the 'label' and
         'catalogue-number' of an album, use:
         'select=admin(label;catalogue-number)'.

         '/' is used in a path to retreive a child node of a node.
         For example, to retreive only the 'label' of an album, use:
         'select=admin/label'.

         This parameter is only allowed for GET methods on api,
         datastore, and data resources.  A 400 Bad Request error
         is returned if used for other methods or resource types.";
    reference
      "RFC XXXX: [sec. 5.3.1.1 ABNF For Data Resource Identifiers]";
    }

    leaf start-time {
      type yang:date-and-time;
      description
        "The 'start-time' parameter is used to trigger
         the notification replay feature and indicate
         that the replay should start at the time specified.
         If the stream does not support replay, per the
         'replay-support' attribute returned by
         the /restconf/streams resource, then the server MUST
         return the HTTP error code 400 Bad Request.

         This parameter is only allowed for GET methods on a
         text/event-stream data resource.  A 400 Bad Request error
         is returned if used for other methods or resource types.

         If this parameter is not present, then a replay subscription
         is not begin requested.  It is not valid to specify start
         times that are later than the current time.  If the value
         specified is earlier than the log can support, the replay
         will begin with the earliest available notification";
    }

    leaf stop-time {
      type yang:date-and-time;
      description
        "The 'stop-time' parameter is used with the
         replay feature to indicate the newest notifications of
         interest.  This parameter MUST be used with and have a
         value later than the 'start-time' parameter.

         This parameter is only allowed for GET methods on a
         text/event-stream data resource.  A 400 Bad Request error
         is returned if used for other methods or resource types.

         If this parameter is not present, the notifications will
         continue until the subscription is terminated.
         Values in the future are valid.";
    }

  }  // grouping query-parameters


  grouping notification {
    description
      "Contains the notification message wrapper definition.";

    container notification {
      description
        "RESTCONF notification message wrapper.";

      leaf event-time {
        type yang:date-and-time;
        mandatory true;
        description
          "The time the event was generated by the
           event source.";
        reference
          "RFC 5277, section 4, <eventTime> element.";
      }

      /* The YANG-specific notification container is encoded
       * after the 'event-time' element.  The format
       * corresponds to the notificationContent element
       * in RFC 5277, section 4. For example:
       *
       *  module example-one {
       *     ...
       *     notification event1 { ... }
       *
       *  }
       *
       *  Encoded as element 'event1' in the namespace
       *  for module 'example-one'.
       */
    }
  }  // grouping notification

}
	    ]]></artwork>
	</figure>
<t>&lt;CODE ENDS></t>
</section>
<section title="IANA Considerations" anchor="iana">
<section title="The &quot;restconf&quot; Relation Type">
    <t>
This specification registers the &quot;restconf&quot; relation type in the Link
Relation Type Registry defined by <xref target="RFC5988"/>:
    </t>
	<figure>
	    <artwork><![CDATA[
   Relation Name:  restconf

   Description:  Identifies the root of RESTCONF API as configured
                 on this HTTP server.  The "restconf" relation
                 defines the root of the API defined in RFCXXXX.
                 Subsequent revisions of RESTCONF will use alternate
                 relation values to support protocol versioning.

   Reference:  RFC XXXX
	    ]]></artwork>
	</figure>
    <t>
`
    </t>
</section>
<section title="YANG Module Registry">
    <t>
This document registers one URI in the IETF XML registry
<xref target="RFC3688"/>. Following the format in RFC 3688, the following
registration is requested to be made.
    </t>
	<figure>
	    <artwork><![CDATA[
     URI: urn:ietf:params:xml:ns:yang:ietf-restconf
     Registrant Contact: The NETMOD WG of the IETF.
     XML: N/A, the requested URI is an XML namespace.
	    ]]></artwork>
	</figure>
    <t>
This document registers one YANG module in the YANG Module Names
registry <xref target="RFC6020"/>.
    </t>
	<figure>
	    <artwork><![CDATA[
  name:         ietf-restconf
  namespace:    urn:ietf:params:xml:ns:yang:ietf-restconf
  prefix:       rc
  // RFC Ed.: replace XXXX with RFC number and remove this note
  reference:    RFC XXXX
	    ]]></artwork>
	</figure>
</section>
<section title="application/yang Media Sub Types">
    <t>
The parent MIME media type for RESTCONF resources is application/yang,
which is defined in <xref target="RFC6020"/>.  This document defines the following
sub-types for this media type.
    </t>
	<figure>
	    <artwork><![CDATA[
   - api
   - data
   - datastore
   - errors
   - operation
   - stream

   Type name: application

   Subtype name: yang.xxx

   Required parameters: TBD

   Optional parameters: TBD

   Encoding considerations: TBD

   Security considerations: TBD

   Interoperability considerations: TBD

   // RFC Ed.: replace XXXX with RFC number and remove this note
   Published specification: RFC XXXX
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Security Considerations">
    <t>
This section provides security considerations for the resources
defined by the RESTCONF protocol.  Security considerations for
HTTPS are defined in <xref target="RFC2818"/>.  Security considerations for the
content manipulated by RESTCONF can be found in the documents
defining data models.
    </t>
    <t>
This document does not specify an authentication scheme, but
it does require that an authenticated NETCONF username be
associated with each HTTP request.  The authentication scheme
MAY be implemented in the underlying transport layer (e.g.,
client certificates) or within the HTTP layer (e.g., Basic
Auth, OAuth, etc.).  RESTCONF does not itself define an
authentication mechanism, authentication MUST occur in a
lower layer.  Implementors SHOULD provide a comprehensive
authorization scheme with RESTCONF and ensure that the resulting
NETCONF username is made available to the RESTCONF server.
    </t>
    <t>
Authorization of individual user access to operations and data
MAY be configured via NETCONF Access Control Model (NACM)
<xref target="RFC6536"/>, as specified in <xref target="operations"/>.  Other authorization
models MAY be used, but are outside of the scope of this
document.
    </t>
    <t>
Configuration information is by its very nature sensitive.  Its
transmission in the clear and without integrity checking leaves
devices open to classic eavesdropping and false data injection
attacks.  Configuration information often contains passwords, user
names, service descriptions, and topological information, all of
which are sensitive.  Because of this, this protocol SHOULD be
implemented carefully with adequate attention to all manner of attack
one might expect to experience with other management interfaces.
    </t>
    <t>
Different environments may well allow different rights prior to and
then after authentication.  When an operation is not properly authorized,
the RESTCONF server MUST return HTTP error status code 401 Unauthorized.
Note that authorization information can be exchanged in the form of
configuration information, which is all the more reason to ensure the
security of the connection.
    </t>
</section>
</middle>
<back>
<references title="Normative References">

  <reference anchor="RFC2119">
    <front>
      <title>Key words for use in RFCs to Indicate Requirement Levels</title>
      <author initials="S." surname="Bradner" fullname="S.  Bradner">
        <organization>Harvard University</organization>
      </author>
      <date month="March" year="1997"/>
      <abstract>
        <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized.  This document defines these words as they should be interpreted in IETF documents.</t>
      </abstract>
    </front>
    <seriesInfo name="BCP" value="14"/>
    <seriesInfo name="RFC" value="2119"/>
    <format type="TXT" octets="4723" target="ftp://ftp.isi.edu/in-notes/rfc2119.txt"/>
  </reference>


  <reference anchor="RFC2246">
    <front>
      <title>The TLS Protocol, Version 1.0</title>
      <author initials="T.D" surname="Dierks" fullname="Tim  Dierks">
        <organization>Certicom</organization>
      </author>
      <author initials="C.A" surname="Allen" fullname="Christopher  Allen">
        <organization>Certicom</organization>
      </author>
      <date month="January" year="1999"/>
      <abstract>
        <t>This document specifies Version 1.0 of the Transport Layer Security
        (TLS) protocol. The TLS protocol provides communications privacy over
        the Internet. The protocol allows client/server applications to
        communicate in a way that is designed to prevent eavesdropping,
        tampering, or message forgery.</t>
      </abstract>
    </front>
    <seriesInfo name="RFC" value="2246"/>
    <format type="HTTP" octets="205788" target="http://tools.ietf.org/html/rfc2246"/>
  </reference>


<reference anchor='RFC2396'>

<front>
<title abbrev='URI Generic Syntax'>Uniform Resource Identifiers (URI): Generic Syntax</title>
<author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
<organization abbrev='MIT/LCS'>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<author initials='R.T.' surname='Fielding' fullname='Roy T. Fielding'>
<organization abbrev='U.C. Irvine'>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials='L.' surname='Masinter' fullname='Larry Masinter'>
<organization abbrev='Xerox Corporation'>Xerox PARC</organization>
<address>
<postal>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<facsimile>+1(415)812-4333</facsimile>
<email>masinter@parc.xerox.com</email></address></author>
<date year='1998' month='August' />
<area>Applications</area>
<keyword>uniform resource</keyword>
<keyword>URI</keyword>
<abstract>
<t>
   A Uniform Resource Identifier (URI) is a compact string of characters
   for identifying an abstract or physical resource.  This document
   defines the generic syntax of URI, including both absolute and
   relative forms, and guidelines for their use; it revises and replaces
   the generic definitions in RFC 1738 and RFC 1808.
</t>
<t>
   This document defines a grammar that is a superset of all valid URI,
   such that an implementation can parse the common components of a URI
   reference without knowing the scheme-specific requirements of every
   possible identifier type.  This document does not define a generative
   grammar for URI; that task will be performed by the individual
   specifications of each URI scheme.
</t></abstract>
<note title='IESG Note'>
<t>
   This paper describes a "superset" of operations that can be applied
   to URI.  It consists of both a grammar and a description of basic
   functionality for URI.  To understand what is a valid URI, both the
   grammar and the associated description have to be studied.  Some of
   the functionality described is not applicable to all URI schemes, and
   some operations are only possible when certain media types are
   retrieved using the URI, regardless of the scheme used.
</t></note></front>

<seriesInfo name='RFC' value='2396' />
<format type='TXT' octets='83639' target='http://www.rfc-editor.org/rfc/rfc2396.txt' />
<format type='HTML' octets='130638' target='http://xml.resource.org/public/rfc/html/rfc2396.html' />
<format type='XML' octets='104983' target='http://xml.resource.org/public/rfc/xml/rfc2396.xml' />
</reference>
<!-- end RFC 2396 -->


<reference anchor="RFC2616">

<front>
<title abbrev="HTTP/1.1">Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="UC Irvine">Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="J." surname="Gettys" fullname="James Gettys">
<organization abbrev="Compaq/W3C">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>jg@w3.org</email></address></author>
<author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
<organization abbrev="Compaq">Compaq Computer Corporation</organization>
<address>
<postal>
<street>Western Research Laboratory</street>
<street>250 University Avenue</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94305</code></postal>
<email>mogul@wrl.dec.com</email></address></author>
<author initials="H." surname="Frystyk" fullname="Henrik Frystyk Nielsen">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>frystyk@w3.org</email></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Xerox">Xerox Corporation</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<email>masinter@parc.xerox.com</email></address></author>
<author initials="P." surname="Leach" fullname="Paul J. Leach">
<organization abbrev="Microsoft">Microsoft Corporation</organization>
<address>
<postal>
<street>1 Microsoft Way</street>
<city>Redmond</city>
<region>WA</region>
<code>98052</code></postal>
<email>paulle@microsoft.com</email></address></author>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<date year="1999" month="June"/>
<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers . A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.
</t>
<t>
   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as "HTTP/1.1", and is an update to RFC 2068 .
</t></abstract></front>

<seriesInfo name="RFC" value="2616"/>
<format type="TXT" octets="422317" target="http://www.rfc-editor.org/rfc/rfc2616.txt"/>
<format type="PS" octets="5529857" target="http://www.rfc-editor.org/rfc/rfc2616.ps"/>
<format type="PDF" octets="550558" target="http://www.rfc-editor.org/rfc/rfc2616.pdf"/>
<format type="HTML" octets="636125" target="http://xml.resource.org/public/rfc/html/rfc2616.html"/>
<format type="XML" octets="493420" target="http://xml.resource.org/public/rfc/xml/rfc2616.xml"/>
</reference>  

  <reference anchor='RFC2818'>
    <front>
      <title>The IETF XML Registry</title>
      <author initials='E.R.' surname='Rescorla' fullname='Erir Rescorla'>
        <organization>RTFM, Inc.</organization></author>
      <date year='2000' month='May' />
      <abstract>
        <t>This memo describes how to use TLS to secure HTTP connections over
   the Internet. Current practice is to layer HTTP over SSL (the
   predecessor to TLS), distinguishing secured traffic from insecure
   traffic by the use of a different server port. This document
   documents that practice using TLS. A companion document describes a
   method for using HTTP/TLS over the same port as normal HTTP
   [RFC2817].</t>
      </abstract>
    </front>
    <seriesInfo name='RFC' value='2818' />
    <format type='HTTP' octets='26507' target='http://tools.ietf.org/html/rfc2818' />
  </reference>
  

  <reference anchor='RFC3688'>
    <front>
      <title>The IETF XML Registry</title>
      <author initials='M.' surname='Mealling' fullname='M. Mealling'>
        <organization /></author>
      <date year='2004' month='January' />
      <abstract>
        <t>This document describes an IANA maintained registry for IETF standards which use Extensible Markup Language (XML) related items such as Namespaces, Document Type Declarations (DTDs), Schemas, and Resource Description Framework (RDF) Schemas.</t></abstract></front>
    
    <seriesInfo name='BCP' value='81' />
    <seriesInfo name='RFC' value='3688' />
    <format type='TXT' octets='17325' target='http://www.rfc-editor.org/rfc/rfc3688.txt' />
  </reference>
  
<reference anchor="RFC3986">

<front>
<title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
<address>
<postal>
<street>Massachusetts Institute of Technology</street>
<street>77 Massachusetts Avenue</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code>
<country>USA</country></postal>
<phone>+1-617-253-5702</phone>
<facsimile>+1-617-258-5999</facsimile>
<email>timbl@w3.org</email>
<uri>http://www.w3.org/People/Berners-Lee/</uri></address></author>
<author initials="R." surname="Fielding" fullname="Roy T. Fielding">
<organization abbrev="Day Software">Day Software</organization>
<address>
<postal>
<street>5251 California Ave., Suite 110</street>
<city>Irvine</city>
<region>CA</region>
<code>92617</code>
<country>USA</country></postal>
<phone>+1-949-679-2960</phone>
<facsimile>+1-949-679-2972</facsimile>
<email>fielding@gbiv.com</email>
<uri>http://roy.gbiv.com/</uri></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
<address>
<postal>
<street>345 Park Ave</street>
<city>San Jose</city>
<region>CA</region>
<code>95110</code>
<country>USA</country></postal>
<phone>+1-408-536-3024</phone>
<email>LMM@acm.org</email>
<uri>http://larry.masinter.net/</uri></address></author>
<date year="2005" month="January"/>
<area>Applications</area>
<keyword>uniform resource identifier</keyword>
<keyword>URI</keyword>
<keyword>URL</keyword>
<keyword>URN</keyword>
<keyword>WWW</keyword>
<keyword>resource</keyword>
<abstract>
<t>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.
</t></abstract></front>

<seriesInfo name="STD" value="66"/>
<seriesInfo name="RFC" value="3986"/>
<format type="TXT" octets="141811" target="http://www.rfc-editor.org/rfc/rfc3986.txt"/>
<format type="HTML" octets="213584" target="http://xml.resource.org/public/rfc/html/rfc3986.html"/>
<format type="XML" octets="163534" target="http://xml.resource.org/public/rfc/xml/rfc3986.xml"/>
</reference>

  <reference anchor='RFC5277'>
      <front>
        <title>NETCONF Event Notifications</title>
        <author initials='S.C.' surname='Chisholm' fullname='S. Chisholm'>
          <organization>Nortel</organization>
        </author>
        <author initials='H.T.' surname='Trevino' fullname='H. Trevino'>
          <organization>Cisco</organization>
        </author>
        <date year='2008' month='July'/>
        <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
      </front>
      <seriesInfo name='RFC' value='5277'/>
    <format type="HTML" octets="96192" target="http://tools.ietf.org/html/rfc5277.html"/>
  </reference>


  <reference anchor='RFC5280'>
      <front>
        <title>Internet X.509 Public Key Infrastructure Certificate
             and Certificate Revocation List (CRL) Profile</title>

        <author initials='D.C.' surname='Cooper' fullname='David Cooper'>
          <organization>NIST</organization>
        </author>
        <author initials='S.S.' surname='Santesson' fullname='Stefan Santesson'>
          <organization>Microsoft</organization>
        </author>
        <author initials='S.F.' surname='Farrell' fullname='Stephen Farrell'>
          <organization>Trinity College Dublin</organization>
        </author>
        <author initials='S.B.' surname='Boeyen' fullname='Sharon Boeyen'>
          <organization>Entrust</organization>
        </author>
        <author initials='R.H.' surname='Housley' fullname='Russell Housley'>
          <organization>Vigil Security</organization>
        </author>
        <author initials='T.P.' surname='Polk' fullname='Tim Polk'>
          <organization>NIST</organization>
        </author>
        <date year='2008' month='May'/>
        <abstract>
          <t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate
   revocation list (CRL) for use in the Internet.  An overview of this
   approach and model is provided as an introduction.  The X.509 v3
   certificate format is described in detail, with additional
   information regarding the format and semantics of Internet name
   forms.  Standard certificate extensions are described and two
   Internet-specific extensions are defined.  A set of required
   certificate extensions is specified.  The X.509 v2 CRL format is
   described in detail along with standard and Internet-specific
   extensions.  An algorithm for X.509 certification path validation is
   described.  An ASN.1 module and examples are provided in the
   appendices.</t>
      </abstract>
      </front>
      <seriesInfo name='RFC' value='5280'/>
    <format type="HTML" octets="430252" target="http://tools.ietf.org/html/rfc5280"/>
  </reference>





<reference anchor="RFC5789">

<front>
<title>PATCH Method for HTTP</title>
<author initials="L." surname="Dusseault" fullname="L. Dusseault">
<organization/></author>
<author initials="J." surname="Snell" fullname="J. Snell">
<organization/></author>
<date year="2010" month="March"/>
<abstract>
<t>Several applications extending the Hypertext Transfer Protocol (HTTP) require a feature to do partial resource modification.  The existing HTTP PUT method only allows a complete replacement of a document.  This proposal adds a new HTTP method, PATCH, to modify an existing HTTP resource. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name="RFC" value="5789"/>
<format type="TXT" octets="21706" target="http://www.rfc-editor.org/rfc/rfc5789.txt"/>
</reference>

<!--
<reference anchor='RFC5785'>
<front>
<title>Defining Well-Known Uniform Resource Identifiers (URIs)</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
<organization /></author>
<author initials='E.' surname='Hammer-Lahav' fullname='E. Hammer-Lahav'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>This memo defines a path prefix for "well-known locations", "/.well-known/", in selected Uniform Resource Identifier (URI) schemes. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5785' />
<format type='TXT' octets='13779' target='http://www.rfc-editor.org/rfc/rfc5785.txt' />
</reference>
-->

  <reference anchor='RFC5988'>
      <front>
        <title>Web Linking</title>
        <author initials='M.N.' surname='Nottingham' fullname='Mark Nottingham'>
          <organization/>
        </author>
        <date year='2010' month='October'/>
      </front>
      <seriesInfo name='RFC' value='5988'/>
  </reference>

  <reference anchor="RFC6020">
    <front>
      <title>YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)</title>
      <author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
        <organization/>
      </author>
      <date year="2010" month="October"/>
      <abstract>
        <t>YANG is a data modeling language used to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF remote procedure calls, and NETCONF notifications. [STANDARDS TRACK]</t>
      </abstract>
    </front>
    <seriesInfo name="RFC" value="6020"/>
    <format type="TXT" octets="324178" target="http://www.rfc-editor.org/rfc/rfc6020.txt"/>
  </reference>


  <reference anchor='RFC6241'>
      <front>
        <title>Network Configuration Protocol (NETCONF)</title>
        <author initials='R.' surname='Enns' fullname='R. Enns' role="editor">
          <organization/>
        </author>
        <author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role="editor">
          <organization/>
        </author>
        <author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder' role="editor">
          <organization/>
        </author>
        <author initials='A.' surname='Bierman' fullname='A. Bierman' role="editor">
          <organization/>
        </author>
        <date year='2011' month='June'/>
      </front>
      <seriesInfo name='RFC' value='6241'/>
  </reference>


<reference anchor="RFC6536">
<front>
<title>Network Configuration Protocol (NETCONF) Access Control Model</title>
<author initials="A." surname="Bierman" fullname="A. Bierman">
<organization/></author>
<author initials="M." surname="Bjorklund" fullname="M. Bjorklund">
<organization/></author>
<date year="2012" month="March"/>
<abstract>
<t>The standardization of network configuration interfaces for use with the Network Configuration Protocol (NETCONF) requires a structured and secure operating environment that promotes human usability and multi-vendor interoperability.  There is a need for standard mechanisms to restrict NETCONF protocol access for particular users to a pre-configured subset of all available NETCONF protocol operations and content.  This document defines such an access control model. [STANDARDS-TRACK]</t></abstract></front>
<seriesInfo name="RFC" value="6536"/>
<format type="TXT" octets="90803" target="http://www.rfc-editor.org/rfc/rfc6536.txt"/>
</reference>


  <reference anchor='RFC6570'>
      <front>
        <title>URI Template</title>
        <author initials='J.G.' surname='Gregorio' fullname='Joe Gregorio'>
          <organization>Google</organization>
        </author>
        <author initials='R.F.' surname='Fielding' fullname='Roy Fielding'>
          <organization>Adobe</organization>
        </author>
        <author initials='M.H.' surname='Hadley' fullname='Marc Hadley'>
          <organization>MITRE</organization>
        </author>
        <author initials='M.N.' surname='Nottingham' fullname='Mark Nottingham'>
          <organization>Rackspace</organization>
        </author>
        <author initials='D.O.' surname='Orchard' fullname='David Orchard'>
          <organization>Salesforce.com</organization>
        </author>
        <date year='2012' month='March'/>
      </front>
      <seriesInfo name='RFC' value='6570'/>
  </reference>


  <reference anchor='rest-dissertation'>
      <front>
        <title>Architectural Styles and
the Design of Network-based Software Architectures</title>
        <author initials='R.F.' surname='Fielding' fullname='Roy Fielding'>
          <organization>University of California, Irvine</organization>
        </author>
        <date year='2000'/>
      </front>
  </reference>


  <reference anchor="I-D.lhotka-netmod-json">
    <front>
      <title>Modeling JSON Text with YANG</title>
      <author initials="L." surname="Lhotka" fullname="L. Lhotka">
        <organization>CZ.NIC</organization>
      </author>
      <date year="2013" month="September"/>
    </front>
    <seriesInfo name="Internet-Draft"
                value="draft-lhotka-netmod-yang-json-02"/>
    <format type='TXT'
    target='http://www.ietf.org/id/draft-lhotka-netmod-yang-json-02.txt'/>
  </reference>

<reference anchor='RFC6415'>
<front>
<title>Web Host Metadata</title>
<author initials='E.' surname='Hammer-Lahav' fullname='Eran Hammer-Lahav'><organization /></author>
<author initials='B.C.' surname='Cook' fullname='Blaine Cook'><organization /></author>
<date year='2011' month='October' />
</front>
<seriesInfo name='RFC' value='6415' />
<format type='TXT' octets='32018' target='http://www.rfc-editor.org/rfc/rfc6415.txt' />
</reference>


<reference anchor='RFC6991'>

<front>
<title>Common YANG Data Types</title>
<author initials='J.' surname='Schoenwaelder' fullname='J. Schoenwaelder'>
<organization /></author>
<date year='2013' month='July' />
<abstract>
<t>This document introduces a collection of common data types to be used with the YANG data modeling language.  This document obsoletes RFC 6021.</t></abstract></front>

<seriesInfo name='RFC' value='6991' />
<format type='TXT' octets='60242' target='http://www.rfc-editor.org/rfc/rfc6991.txt' />
</reference>

<reference anchor='wd-eventsource'>

<front>
<title>Server-Sent Events</title>
<author initials='I.H.' surname='Hickson' fullname='Ian Hickson'>
<organization>Google Inc.</organization></author>
<date year='2012' month='December' />
<abstract>
<t>This specification defines an API for opening an HTTP connection for receiving push notifications from a server in the form of DOM events. The API is designed such that it can be extended to work with other push notification schemes such as Push SMS.</t></abstract></front>

<format type='HTML' octets='73384' target='http://www.w3.org/TR/eventsource/' />
</reference>

<reference anchor='W3C.REC-xml-20081126'
           target='http://www.w3.org/TR/2008/REC-xml-20081126'>
<front>
<title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>

<author initials='F.' surname='Yergeau' fullname='Franois Yergeau'>
    <organization />
</author>

<author initials='E.' surname='Maler' fullname='Eve Maler'>
    <organization />
</author>

<author initials='J.' surname='Paoli' fullname='Jean Paoli'>
    <organization />
</author>

<author initials='C.' surname='Sperberg-McQueen' fullname='C. M. Sperberg-McQueen'>
    <organization />
</author>

<author initials='T.' surname='Bray' fullname='Tim Bray'>
    <organization />
</author>

<date month='November' day='26' year='2008' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xml-20081126' />
<format type='HTML' target='http://www.w3.org/TR/2008/REC-xml-20081126' />
</reference>

<reference anchor="JSON">
      <front>
        <title>The JSON Data Interchange Format</title>
        <author initials="T." surname="Bray"
                fullname="T. Bray" role="editor">
          <organization />
        </author>
        <date month="December" day="19" year="2013" />
      </front>
      <seriesInfo name="Internet-Draft"
                  value="draft-ietf-json-rfc4627bis-10" />
      <format
          type="HTML"
          target="http://tools.ietf.org/html/draft-ietf-json-rfc4627bis-10"/>
</reference>


<reference anchor="get-off-my-lawn">
      <front>
        <title>URI Design and Ownership</title>
        <author initials="M." surname="Nottingham"
                fullname="Mark Nottingham">
          <organization />
        </author>
        <date month="May" day="21" year="2014" />
      </front>
      <seriesInfo name="Best Current Practice"
                  value="draft-ietf-appsawg-uri-get-off-my-lawn-05" />
      <format
          type="TXT"
          target="http://tools.ietf.org/id/draft-ietf-appsawg-uri-get-off-my-lawn-05.txt"/>
</reference>


</references>

<references title="Informative References">
<reference anchor="XPath" target="http://www.w3.org/TR/1999/REC-xpath-19991116">
      <front>
        <title>XML Path Language (XPath) Version 1.0</title>
        <author initials="J." surname="Clark" fullname="James Clark">
          <organization/>
        </author>
        <author initials="S." surname="DeRose" fullname="Steven DeRose">
          <organization/>
        </author>
        <date month="November" day="16" year="1999"/>
      </front>
      <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-xpath-19991116"/>
      <format type="HTML" target="http://www.w3.org/TR/1999/REC-xpath-19991116"/>
</reference>
</references>
<section title="Change Log">
	<figure>
	    <artwork><![CDATA[
    -- RFC Ed.: remove this section before publication.
	    ]]></artwork>
	</figure>
<section title="00 - 01">
<t>
 <list style="symbols">
 <t>
fixed content=nonconfig example (non-config was incorrect)
 </t>
 <t>
closed open issue &apos;message&#8209;id&apos;.  There is no need for a message-id
field, and RFC 2392 does not apply.
 </t>
 <t>
closed open issue &apos;server support verification&apos;. The headers used
by RESTCONF are widely supported.
 </t>
 <t>
removed encoding rules from section on RESTCONF Meta-Data. This is now
defined in <xref target="I-D.lhotka-netmod-json"/>.
 </t>
 <t>
added media type application/yang.errors to map to errors YANG grouping.
Updated error examples to use new media type.
 </t>
 <t>
closed open issue &apos;additional datastores&apos;. Support may be added in the
future to identify new datastores.
 </t>
 <t>
closed open issue &apos;PATCH media type discovery&apos;. The section
on PATCH has an added sentence on the Accept-Patch header.
 </t>
 <t>
closed open issue &apos;YANG to resource mapping&apos;. Current mapping
of all data nodes to resources will be used in order to allow
mandatory DELETE support. The PATCH operation is optional,
as well as the YANG Patch media type.
 </t>
 <t>
closed open issue &apos;_self links for HATEOAS support&apos;. It was decided
that they are redundant because they can be derived from the YANG module
for the specific data.
 </t>
 <t>
added explanatory text for the &apos;select&apos; parameter.
 </t>
 <t>
added RESTCONF Path Resolution section for discovering the
root of the RESTCONF API using the /.well-known/host-meta.
 </t>
 <t>
added an &quot;error&quot; media type to for structured error messages
 </t>
 <t>
added Secure Transport section requiring TLS
 </t>
 <t>
added Security Considerations section
 </t>
 <t>
removed all references to &quot;REST&#8209;like&quot;
 </t>
 </list>
</t>
</section>
<section title="bierman:restconf-04 to ietf:restconf-00">
<t>
 <list style="symbols">
 <t>
updated open issues section
 </t>
 </list>
</t>
</section>
</section>
<section title="Open Issues">
	<figure>
	    <artwork><![CDATA[
    -- RFC Ed.: remove this section before publication.
	    ]]></artwork>
	</figure>
<section title="select parameter">
<t>
 <list style="symbols">
 <t>
What syntax should be used for the &quot;select&quot; query parameter?
The current choices are &quot;XPath&quot; and &quot;path&#8209;expr&quot;.  Perhaps an additional
parameter to identify the select string format is needed
to allow extensibility?
 </t>
 </list>
</t>
    <t>
Status: solution proposal added by Martin.
    </t>
</section>
<section title="netconf-state monitoring support">
<t>
 <list style="symbols">
 <t>
Should long-term RESTCONF operations (i.e. SSE long-poll)
be considered sessions with regards to NETCONF monitoring &quot;session&quot; list?
If so, what text is needed in RESTCONF draft to standardize
the RESTCONF session entries?
 </t>
 </list>
</t>
    <t>
Status: closed-update-pending
    </t>
    <t>
Resolution:
    </t>
    <t>
A new data structure to monitor streams can be added
to the netconf-state sub-tree.  The session-id in
this new data structure is not restricted to the
NETCONF-only rules for the sessions sub-tree.
    </t>
</section>
<section title="secure transport">
<t>
 <list style="symbols">
 <t>
Details to support secure operation over TLS are needed
 </t>
 </list>
</t>
    <t>
Status: closed
    </t>
<t>
 <list style="symbols">
 <t>
Security considerations need to be written
 </t>
 </list>
</t>
    <t>
Status: closed
    </t>
<t>
 <list style="symbols">
 <t>
Can call-home for RESTCONF be supported
 </t>
 </list>
</t>
    <t>
Status: open
    </t>
</section>
<section title="Encoding of key leafs in resource URIs">
<t>
 <list style="symbols">
 <t>
The use of a forward slash &apos;/&apos; as the delimiter between
key values in a target resource URI is not not desirable.
Only 1 segment per YANG data node layer should be used.
 </t>
 </list>
</t>
    <t>
Status: open
    </t>
    <t>
Proposals:
    </t>
    <t>
Example: list foo, int8 keys X and Y
    </t>
    <t>
Old:
    </t>
	<figure>
	    <artwork><![CDATA[
  /restconf/data/foo/19/22/foo-leaf
	    ]]></artwork>
	</figure>
    <t>
New:
    </t>
	<figure>
	    <artwork><![CDATA[
  /restconf/data/foo=19,22/foo-leaf
	    ]]></artwork>
	</figure>
    <t>
Or:
    </t>
	<figure>
	    <artwork><![CDATA[
  /restconf/data/foo/19,22/foo-leaf
	    ]]></artwork>
	</figure>
</section>
<section title="get-bulk query parameters">
<t>
 <list style="symbols">
 <t>
New query parameters (e.g., offset, limit) are needed
to retrieve a limited number of list instances.
 </t>
 </list>
</t>
    <t>
Status: solution proposal pending
    </t>
    <t>
Resolution: This bulk retrieval mechanism will be added.
    </t>
</section>
<section title="defaults handling">
<t>
 <list style="symbols">
 <t>
The client does not really know what sort of defaults
the server will return in GET replies.  Should the
with-defaults query parameter be added to RESTCONF?
If so, should it be mandatory-to-implement?
 </t>
 </list>
</t>
    <t>
Status: open
    </t>
</section>
<section title="protocol capability URIs">
<t>
 <list style="symbols">
 <t>
The client does not know what vendor extensions (if any)
are implemented by the server. Should the server provide
a read-only container of capability URIs to identify protocol extensions?
The NETMOD WG may also want to extend the protocol in the future
without updating the core RESTCONF RFC.
 </t>
 </list>
</t>
    <t>
Status: open
    </t>
</section>
<section title="target resource list keys required for GET">
<t>
 <list style="symbols">
 <t>
Should the client be able to GET all or a subset of all list instances
by issuing a GET without any list keys for the target resource list?
 </t>
 </list>
</t>
	<figure>
	    <artwork><![CDATA[
  GET /restconf/data/interfaces/interface
	    ]]></artwork>
	</figure>
<t>
 <list style="symbols">
 <t>
Should a &quot;collection&quot; resource be required in order for such a request
to be considered valid by the server.
 </t>
 </list>
</t>
    <t>
Status: open
    </t>
</section>
</section>
<section title="Example YANG Module">
    <t>
The example YANG module used in this document represents
a simple media jukebox interface.
    </t>
    <t>
YANG Tree Diagram for &quot;example&#8209;jukebox&quot; Module
    </t>
	<figure>
	    <artwork><![CDATA[
   +--rw jukebox?
      +--rw library
      |  +--rw artist [name]
      |  |  +--rw name     string
      |  |  +--rw album [name]
      |  |     +--rw name     string
      |  |     +--rw genre?   identityref
      |  |     +--rw year?    uint16
      |  |     +--rw admin
      |  |     |  +--rw label?              string
      |  |     |  +--rw catalogue-number?   string
      |  |     +--rw song [name]
      |  |        +--rw name        string
      |  |        +--rw location    string
      |  |        +--rw format?     string
      |  |        +--rw length?     uint32
      |  +--ro artist-count?   uint32
      |  +--ro album-count?    uint32
      |  +--ro song-count?     uint32
      +--rw playlist [name]
      |  +--rw name           string
      |  +--rw description?   string
      |  +--rw song [index]
      |     +--rw index    uint32
      |     +--rw id       instance-identifier
      +--rw player
         +--rw gap?   decimal64
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
  rpcs:
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   +---x play
      +--ro input
         +--ro playlist       string
         +--ro song-number    uint32
	    ]]></artwork>
	</figure>
<section title="example-jukebox YANG Module" anchor="example-module">
	<figure>
	    <artwork><![CDATA[
module example-jukebox {

   namespace "http://example.com/ns/example-jukebox";
   prefix "jbox";
   import ietf-restconf { prefix rc; }

   organization "Example, Inc.";
   contact "support at example.com";
   description "Example Jukebox Data Model Module";
   revision "2014-07-03" {
     description "Initial version.";
     reference "example.com document 1-4673";
   }

   identity genre {
     description "Base for all genre types";
   }

   // abbreviated list of genre classifications
   identity alternative {
     base genre;
     description "Alternative music";
   }
   identity blues {
     base genre;
     description "Blues music";
   }
   identity country {
     base genre;
     description "Country music";
   }
   identity jazz {
     base genre;
     description "Jazz music";
   }
   identity pop {
     base genre;
     description "Pop music";
   }
   identity rock {
     base genre;
     description "Rock music";
   }

   container jukebox {
     presence
       "An empty container indicates that the jukebox
        service is available";

     description
       "Represents a jukebox resource, with a library, playlists,
        and a play operation.";

     container library {

       description "Represents the jukebox library resource.";

       list artist {
         key name;

         description
           "Represents one artist resource within the
            jukebox library resource.";

         leaf name {
           type string {
             length "1 .. max";
           }
           description "The name of the artist.";
         }

         list album {
           key name;

           description
             "Represents one album resource within one
              artist resource, within the jukebox library.";

           leaf name {
             type string {
               length "1 .. max";
             }
             description "The name of the album.";
           }

           leaf genre {
             type identityref { base genre; }
             description
               "The genre identifying the type of music on
                the album.";
           }

           leaf year {
             type uint16 {
               range "1900 .. max";
             }
             description "The year the album was released";
           }

           container admin {
             description
               "Administrative information for the album.";

             leaf label {
               type string;
               description "The label that released the album.";
             }
             leaf catalogue-number {
               type string;
               description "The album's catalogue number.";
             }
           }

           list song {
             key name;

             description
               "Represents one song resource within one
                album resource, within the jukebox library.";

             leaf name {
               type string {
                  length "1 .. max";
               }
               description "The name of the song";
             }
             leaf location {
               type string;
               mandatory true;
               description
                "The file location string of the
                 media file for the song";
             }
             leaf format {
               type string;
               description
                 "An identifier string for the media type
                  for the file associated with the
                  'location' leaf for this entry.";
             }
             leaf length {
               type uint32;
               units "seconds";
               description
                 "The duration of this song in seconds.";
             }
           }   // end list 'song'
         }   // end list 'album'
       }  // end list 'artist'

       leaf artist-count {
          type uint32;
          units "songs";
          config false;
          description "Number of artists in the library";
       }
       leaf album-count {
          type uint32;
          units "albums";
          config false;
          description "Number of albums in the library";
       }
       leaf song-count {
          type uint32;
          units "songs";
          config false;
          description "Number of songs in the library";
       }
     }  // end library

     list playlist {
       key name;

       description
         "Example configuration data resource";

       leaf name {
         type string;
         description
           "The name of the playlist.";
       }
       leaf description {
         type string;
         description
           "A comment describing the playlist.";
       }
       list song {
         key index;
         ordered-by user;

         description
           "Example nested configuration data resource";

         leaf index {    // not really needed
           type uint32;
           description
             "An arbitrary integer index for this
              playlist song.";
         }
         leaf id {
           type rc:data-resource-identifier;
           mandatory true;
           description
             "Song identifier. Must identify an instance of
              /jukebox/library/artist/album/song/name.";
         }
       }
     }

     container player {
       description
         "Represents the jukebox player resource.";

       leaf gap {
         type decimal64 {
           fraction-digits 1;
           range "0.0 .. 2.0";
         }
         units "tenths of seconds";
         description "Time gap between each song";
       }
     }
   }

   rpc play {
     description "Control function for the jukebox player";
     input {
       leaf playlist {
         type string;
         mandatory true;
         description "playlist name";
       }
       leaf song-number {
         type uint32;
         mandatory true;
         description "Song number in playlist to play";
       }
     }
   }
}

	    ]]></artwork>
	</figure>
</section>
</section>
<section title="RESTCONF Message Examples" anchor="main-examples">
    <t>
The examples within this document use the normative
YANG module defined in <xref target="module"/> and the non-normative
example YANG module defined in <xref target="example-module"/>.
    </t>
    <t>
This section shows some typical RESTCONF message exchanges.
    </t>
<section title="Resource Retrieval Examples">
<section title="Retrieve the Top-level API Resource">
    <t>
The client may start by retrieving the top-level
API resource, using the entry point URI &quot;{+restconf}&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf   HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Content-Type: application/yang.api+json

   {
     "ietf-restconf:restconf": {
       "data" : [ null ],
       "modules": {
         "module": [
           {
             "name" : "example-jukebox",
             "revision" : "2014-07-03",
             "namespace" : "http://example.com/ns/example-jukebox",
             "schema" : [ null ]
           }
         ]
       },
       "operations" : {
          "play" : [ null ]
       },
       "streams" : {
         "stream" : [
           {
             "name" : "NETCONF",
             "description" : "default NETCONF event stream",
             "replay-support" : true,
             "replay-log-creation-time:" : "2007-07-08T00:00:00Z",
             "events" : [ null ]
           }
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
To request that the response content to be encoded in XML,
the &quot;Accept&quot; header can be used, as in this example request:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf HTTP/1.1
   Host: example.com
   Accept: application/yang.api+xml,
           application/yang.errors+xml
	    ]]></artwork>
	</figure>
    <t>
The server will return the same response either way,
which might be as follows :
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.api+xml
	    ]]></artwork>
	</figure>
	<figure>
	    <artwork><![CDATA[
   <restconf xmlns="urn:ietf:params:xml:ns:yang:ietf-restconf">
     <data/>
     <modules>
       <module>
         <name>example-jukebox</name>
         <revision>2014-07-03</revision>
         <namespace>
           http://example.com/ns/example-jukebox
         </namespace>
         <schema />
       </module>
     </modules>
     <operations>
       <play xmlns="http://example.com/ns/example-jukebox"/>
     </operations>
     <streams>
       <stream>
         <name>NETCONF</name>
         <description>default NETCONF event stream
         </description>
         <replay-support>true</replay-support>
         <replay-log-creation-time>
            2007-07-08T00:00:00Z
         </replay-log-creation-time>
         <events/>
       </stream>
     </streams>
   </restconf>
	    ]]></artwork>
	</figure>
</section>
<section title="Retrieve The Server Module Information">
    <t>
In this example the client is retrieving the modules
resource from the server in JSON format:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/modules  HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Last-Modified: Sun, 22 Apr 2012 01:00:14 GMT
   Content-Type: application/yang.api+json

   {
     "ietf-restconf:modules": {
       "module": [
         {
           "name" : "foo",
           "revision" : "2012-01-02",
           "schema" : [null],
           "namespace" : "http://example.com/ns/foo",
           "feature" : [ "feature1", "feature2" ]
         },
         {
           "name" : "foo-types",
           "revision" : "2012-01-05",
           "schema" : [null],
           "namespace" : "http://example.com/ns/foo-types"
         },
         {
           "name" : "bar",
           "revision" : "2012-11-05",
           "schema" : [null],
           "namespace" : "http://example.com/ns/bar",
           "feature" : [ "bar-ext" ],
           "submodule" : [
             {
               "name" : "bar-submod1",
               "revision" : "2012-11-05",
               "schema" : [null]
             },
             {
               "name" : "bar-submod2",
               "revision" : "2012-11-05",
               "schema" : [null]
             }
           ]
         }
       ]
     }
   }
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Edit Resource Examples">
<section title="Create New Data Resources" anchor="ex-create">
    <t>
To create a new &quot;artist&quot; resource within the &quot;library&quot;
resource, the client might send the following request.
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/library HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   { "example-jukebox:artist" : {
       "name" : "Foo Fighters"
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond as follows.
Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:02:00 GMT
   Server: example-server
   Location: http://example.com/restconf/data/
        example-jukebox:jukebox/library/artist=Foo%20Fighters
   Last-Modified: Mon, 23 Apr 2012 17:02:00 GMT
   ETag: b3830f23a4c
	    ]]></artwork>
	</figure>
    <t>
To create a new &quot;album&quot; resource for this artist within the &quot;jukebox&quot;
resource, the client might send the following request.
Note that the request URI header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/
      library/artist=Foo%20Fighters  HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:album" : {
       "name" : "Wasting Light",
       "genre" : "example-jukebox:alternative",
       "year" : 2012    # note this is the wrong date
     }
   }
	    ]]></artwork>
	</figure>
    <t>
If the resource is created, the server might respond
as follows.  Note that the &quot;Location&quot; header line is wrapped
for display purposes only:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 17:03:00 GMT
   Server: example-server
   Location: http://example.com/restconf/data/
     example-jukebox:jukebox/library/artist=Foo%20Fighters/
     album=Wasting%20Light
   Last-Modified: Mon, 23 Apr 2012 17:03:00 GMT
   ETag: b8389233a4c
	    ]]></artwork>
	</figure>
</section>
<section title="Detect Resource Entity Tag Change">
    <t>
In this example, the server just supports the
mandatory datastore last-changed timestamp.
The client has previously retrieved the &quot;Last&#8209;Modified&quot;
header and has some value cached to provide in
the following request to patch an &quot;album&quot; list entry
with key value &quot;Wasting Light&quot;. Only the &quot;year&quot; field is being
updated.
    </t>
	<figure>
	    <artwork><![CDATA[
   PATCH /restconf/data/example-jukebox:jukebox/
     library/artist=Foo%20Fighters/album=Wasting%20Light/year
     HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
   If-Unmodified-Since: Mon, 23 Apr 2012 17:01:00 GMT
   Content-Type: application/yang.data+json

   { "example-jukebox:year" : "2011" }
	    ]]></artwork>
	</figure>
    <t>
In this example the datastore resource has changed
since the time specified in the &quot;If&#8209;Unmodified&#8209;Since&quot;
header.  The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 412 Precondition Failed
   Date: Mon, 23 Apr 2012 19:01:00 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 17:45:00 GMT
   ETag: b34aed893a4c
	    ]]></artwork>
	</figure>
</section>
</section>
<section title="Query String Parameter Examples" anchor="ex-query">
<section title="&quot;content&quot; Parameter">
    <t>
The &quot;content&quot; parameter is used to select the type of
data child resources (configuration and/or not configuration)
that are returned by the server for a GET method request.
    </t>
    <t>
In this example, a simple YANG list that has configuration
and non-configuration child resources.
    </t>
	<figure>
	    <artwork><![CDATA[
  container events
    list event {
      key name;
      leaf name { type string; }
      leaf description { type string; }
      leaf event-count {
        type uint32;
        config false;
      }
    }
  }
	    ]]></artwork>
	</figure>
    <t>
Example 1: content=all
    </t>
    <t>
To retrieve all the child resources, the &quot;content&quot; parameter
is set to &quot;all&quot;. The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-events:events?content=all
       HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-events:events" : {
       "event" : [
         {
           "name" : "interface-up",
           "description" : "Interface up notification count",
           "event-count" : 42
         },
         {
           "name" : "interface-down",
           "description" : "Interface down notification count",
           "event-count" : 4
         }
       ]
     }
   }
	    ]]></artwork>
	</figure>
    <t>
Example 2: content=config
    </t>
    <t>
To retrieve only the configuration child resources,
the &quot;content&quot; parameter is set to &quot;config&quot; or omitted
since this is the default value.  Note that the &quot;ETag&quot;
and &quot;Last&#8209;Modified&quot; headers are only returned if
the content parameter value is &quot;config&quot;.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-events:events?content=config
      HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   ETag: eeeada438af
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-events:events" : {
       "event" : [
         {
           "name" : "interface-up",
           "description" : "Interface up notification count"
         },
         {
           "name" : "interface-down",
           "description" : "Interface down notification count"
         }
       ]
     }
   }
	    ]]></artwork>
	</figure>
    <t>
Example 3: content=nonconfig
    </t>
    <t>
To retrieve only the non-configuration child resources,
the &quot;content&quot; parameter is set to &quot;nonconfig&quot;. Note
that configuration ancestors (if any) and list key leafs
(if any) are also returned.  The client might send:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-events:events?content=nonconfig
      HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-events:events" : {
       "event" : [
         {
           "name" : "interface-up",
           "event-count" : 42
         },
         {
           "name" : "interface-down",
           "event-count" : 4
         }
       ]
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;depth&quot; Parameter">
    <t>
The &quot;depth&quot; parameter is used to limit the number of levels
of child resources that are returned by the server for
a GET method request.
    </t>
    <t>
This example shows how different values of the &quot;depth&quot;
parameter would affect the reply content for
retrieval of the top-level &quot;jukebox&quot; data resource.
    </t>
    <t>
Example 1: depth=unbounded
    </t>
    <t>
To retrieve all the child resources, the &quot;depth&quot; parameter
is not present or set to the default value &quot;unbounded&quot;.
Note that some strings are wrapped for display purposes only.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox?depth=unbounded
      HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-jukebox:jukebox" : {
       "library" : {
         "artist" : [
           {
             "name" : "Foo Fighters",
             "album" : [
               {
                 "name" : "Wasting Light",
                 "genre" : "example-jukebox:alternative",
                 "year" : 2011,
                 "song" : [
                   {
                     "name" : "Wasting Light",
                     "location" :
                       "/media/foo/a7/wasting-light.mp3",
                     "format" : "MP3",
                     "length" " 286
                   },
                   {
                     "name" : "Rope",
                     "location" : "/media/foo/a7/rope.mp3",
                     "format" : "MP3",
                     "length" " 259
                   }
                 ]
               }
             ]
           }
         ]
       },
       "playlist" : [
         {
           "name" : "Foo-One",
           "description" : "example playlist 1",
           "song" : [
             {
               "index" : 1,
               "id" : "http://example.com/restconf/data/
                     example-jukebox:jukebox/library/artist/
                     Foo%20Fighters/album/Wasting%20Light/
                     song/Rope"
             },
             {
               "index" : 2,
               "id" : "http://example.com/restconf/data/
                     example-jukebox:jukebox/library/artist/
                     Foo%20Fighters/album/Wasting%20Light/song/
                     Bridge%20Burning"
             }
           ]
         }
       ],
       "player" : {
         "gap" : 0.5
       }
     }
   }
	    ]]></artwork>
	</figure>
    <t>
Example 2: depth=1
    </t>
    <t>
To determine if 1 or more resource instances exist for
a given target resource, the value &quot;1&quot; is used.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox?depth=1 HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-jukebox:jukebox" : [null]
   }
	    ]]></artwork>
	</figure>
    <t>
Example 3: depth=3
    </t>
    <t>
To limit the depth level to the target resource plus 2 child resource layers
the value &quot;3&quot; is used.
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf/data/example-jukebox:jukebox?depth=3 HTTP/1.1
   Host: example.com
   Accept: application/yang.data+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:11:30 GMT
   Server: example-server
   Cache-Control: no-cache
   Pragma: no-cache
   Content-Type: application/yang.data+json

   {
     "example-jukebox:jukebox" : {
       "library" : {
         "artist" : [ null ]
       },
       "playlist" : [
         {
           "name" : "Foo-One",
           "description" : "example playlist 1",
           "song" : [ null ]
         }
       ],
       "player" : {
         "gap" : 0.5
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;filter&quot; Parameter" anchor="ex-filters">
    <t>
The following URIs show some examples of notification filter
specifications (lines wrapped for display purposes only):
    </t>
	<figure>
	    <artwork><![CDATA[
   // filter = /event/eventClass='fault'
   GET /restconf/streams/stream=NETCONF/events?
      filter=%2Fevent%2FeventClass%3D'fault'

   // filter = /event/severityCode<=4
   GET /restconf/streams/stream=NETCONF/events?
      filter=%2Fevent%2FseverityCode%3C%3D4

   // filter = /linkUp|/linkDown
   GET /restconf/streams/stream=SNMP/events?
      filter=%2FlinkUp%7C%2FlinkDown

   // filter = /*/reportingEntity/card!='Ethernet0'
   GET /restconf/streams/stream=NETCONF/events?
      filter=%2F*%2FreportingEntity%2Fcard%21%3D'Ethernet0'

   // filter = /*/email-addr[contains(.,'company.com')]
   GET /restconf/streams/stream=critical-syslog/events?
      filter=%2F*%2Femail-addr[contains(.%2C'company.com')]

   // Note: the module name is used as prefix.
   // filter = (/example-mod:event1/name='joe' and
   //           /example-mod:event1/status='online')
   GET /restconf/streams/stream=NETCONF/events?
     filter=(%2Fexample-mod%3Aevent1%2Fname%3D'joe'%20and
             %20%2Fexample-mod%3Aevent1%2Fstatus%3D'online')
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;insert&quot; Parameter">
    <t>
In this example, a new first entry in the &quot;Foo&#8209;One&quot; playlist
is being created.
    </t>
    <t>
Request from client:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/
     playlist=Foo-One?insert=first HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:song" : {
        "index" : 1,
        "id" : "/example-jukebox:jukebox/library/artist/
            Foo%20Fighters/album/Wasting%20Light/song/Rope"
      }
   }
	    ]]></artwork>
	</figure>
    <t>
Response from server:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 201 Created
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   Location: http://example.com/restconf/data/
      example-jukebox:jukebox/playlist=Foo-One/song=1
   ETag: eeeada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;point&quot; Parameter">
    <t>
Example:
    </t>
    <t>
In this example, the client is inserting a new &quot;song&quot;
resource within an &quot;album&quot; resource after another song.
The request URI is split for display purposes only.
    </t>
    <t>
Request from client:
    </t>
	<figure>
	    <artwork><![CDATA[
   POST /restconf/data/example-jukebox:jukebox/
      library/artist/Foo%20Fighters/album/Wasting%20Light?
      insert=after&point=%2Fexample-jukebox%3Ajukebox%2F
      library%2Fartist%2FFoo%20Fighters%2Falbum%2F
      Wasting%20Light%2Fsong%2FBridge%20Burning   HTTP/1.1
   Host: example.com
   Content-Type: application/yang.data+json

   {
     "example-jukebox:song" : {
        "name" : "Rope",
        "location" : "/media/foo/a7/rope.mp3",
        "format" : "MP3",
        "length" : 259
     }
   }
	    ]]></artwork>
	</figure>
    <t>
Response from server:
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 204 No Content
   Date: Mon, 23 Apr 2012 13:01:20 GMT
   Server: example-server
   Last-Modified: Mon, 23 Apr 2012 13:01:20 GMT
   ETag: abcada438af
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;select&quot; Parameter">
    <t>
In this example the client is retrieving the API resource, but
selecting only the &quot;name&quot; and &quot;revision&quot; nodes
from each module, in JSON format:
    </t>
	<figure>
	    <artwork><![CDATA[
   GET /restconf?select=modules/module(name;revision) HTTP/1.1
   Host: example.com
   Accept: application/yang.api+json,
           application/yang.errors+json
	    ]]></artwork>
	</figure>
    <t>
The server might respond as follows.
    </t>
	<figure>
	    <artwork><![CDATA[
   HTTP/1.1 200 OK
   Date: Mon, 23 Apr 2012 17:01:00 GMT
   Server: example-server
   Content-Type: application/yang.api+json

   {
     "ietf-restconf:restconf": {
       "modules": {
         "module": [
           {
             "name" : "example-jukebox",
             "revision" : "2014-07-03"
           }
         ]
       }
     }
   }
	    ]]></artwork>
	</figure>
</section>
<section title="&quot;start&#8209;time&quot; Parameter">
    <t>
TBD
    </t>
</section>
<section title="&quot;stop&#8209;time&quot; Parameter">
    <t>
TBD
    </t>
</section>
</section>
</section>
</back></rfc>
